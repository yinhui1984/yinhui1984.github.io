

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yinhui</title>
  <subtitle>this is yinhui's blog.</subtitle>
  <updated>2022-06-22T13:07:00+08:00</updated>
  <author>
    <name>zhouyinhui</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator>
  <rights> © 2022 zhouyinhui </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>golang1.18以后slice扩容策略变化</title>
    <link href="http://localhost:4000/posts/golang1.18%E4%BB%A5%E5%90%8Eslice%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5%E5%8F%98%E5%8C%96/" rel="alternate" type="text/html" title="golang1.18以后slice扩容策略变化" />
    <published>2022-06-22T00:00:00+08:00</published>
  
    <updated>2022-06-22T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/golang1.18%E4%BB%A5%E5%90%8Eslice%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5%E5%8F%98%E5%8C%96/</id>
    <content src="http://localhost:4000/posts/golang1.18%E4%BB%A5%E5%90%8Eslice%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5%E5%8F%98%E5%8C%96/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      golang1.18版本以前, 扩容策略:


  当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。


在1.18版本更新之后，slice的扩容策略变为了:


  当原slice容量小于256的时候，新slice容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4



// go@1.17   slice.go

func growslice(et *_type, old slice, cap int) slice {
  
  //....
  newcap := old.cap
	doublecap := newcap + newcap
	if cap &amp;gt; doublecap {
...
    </summary>
  

  </entry>

  
  <entry>
    <title>使用delve对go代码进行调试</title>
    <link href="http://localhost:4000/posts/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/" rel="alternate" type="text/html" title="使用delve对go代码进行调试" />
    <published>2022-06-21T00:00:00+08:00</published>
  
    <updated>2022-06-21T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/</id>
    <content src="http://localhost:4000/posts/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      delve就是go语言的gdb,虽然 gdb也可以调试go程序 (https://go.dev/doc/gdb). 但是, 用gdb调试go程序有这些已知问题:

已知问题


  字符串pretty printing 只对字符串类型触发，而不是对其派生类型。
  运行库的 C 部分缺少类型信息。
  GDB 不理解 Go 的名称资格，并将 “fmt.Print “视为带有”. “的非结构化字面，需要加以引号。它对pkg.(*MyType).Meth形式的方法名反对得更厉害。
  从Go 1.11开始，调试信息默认是压缩的。旧版本的gdb，例如MacOS上默认提供的版本，并不理解压缩。你可以使用go build -ldflags=-compressdwarf=false来生成未压缩的调试信息。(为了方便，你可以把-ldflags选项放在GOFLAGS环境变量中，这样你就不必每次都指定...
    </summary>
  

  </entry>

  
  <entry>
    <title>golang实现一个简单的事件处理程序</title>
    <link href="http://localhost:4000/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/" rel="alternate" type="text/html" title="golang实现一个简单的事件处理程序" />
    <published>2022-06-14T00:00:00+08:00</published>
  
    <updated>2022-06-15T14:41:40+08:00</updated>
  
    <id>http://localhost:4000/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/</id>
    <content src="http://localhost:4000/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      一个简单的事件处理程序.

demo目录结构

.
├── events
│   └── event.go
├── go.mod
├── main.go
└── user
    └── login.go



event.go

package events

import "sync"

type EventHandler func(event Event, arg interface{})

var lock sync.Mutex

type Event interface {
	Name() string
	Register(EventHandler) error
	Trigger(arg interface{}) error
}

type SimpleEvent struct {
	name     string
	handlers []EventHandler
}

f...
    </summary>
  

  </entry>

  
  <entry>
    <title>go语言中Channel是如何工作的</title>
    <link href="http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" rel="alternate" type="text/html" title="go语言中Channel是如何工作的" />
    <published>2022-06-13T00:00:00+08:00</published>
  
    <updated>2022-06-13T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <content src="http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      了解Golang通道的内部工作原理



goroutine(协程)和通道

goroutine是一个轻量级的用户空间线程，由Go运行时管理。它同时执行任务，可能是并行的。

通道是用于goroutine之间的通信。

在这篇文章中，我们将深入了解通道的内部运作和它的发送/接收操作。

缓冲通道

我们先创建一个缓冲通道用于下面的解释。

ch := make(chan int, 3)      


上面的语句创建了一个缓冲通道，最多可以容纳 3 个 int 类型的值。

在底层，make函数 在堆上分配了一个 hchan 结构并返回一个指向它的指针。
以下是 hchan 结构的一些字段及其解释。

![img](./( ../../assets/img/1*wprFXP6zyl8FPC1PhvslsQ.png)

some fields of hchan struct

type...
    </summary>
  

  </entry>

  
  <entry>
    <title>golang http server</title>
    <link href="http://localhost:4000/posts/golang_http_server/" rel="alternate" type="text/html" title="golang http server" />
    <published>2022-06-13T00:00:00+08:00</published>
  
    <updated>2022-06-13T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/golang_http_server/</id>
    <content src="http://localhost:4000/posts/golang_http_server/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      golang 中http server 基础知识.

简单的文件服务器

package main

import (
	"log"
	"net/http"
)

func main() {
	err := http.ListenAndServe(":8080", http.FileServer(http.Dir(".")))
	if err != nil {
		log.Fatal(err)
	}
}


上面这个例子创建了一个以当前目录为站点跟目录的文件服务器,  我一般用这个来作为局域网文件共享.

然后写一个函数放到bash.rc 或zshrc中

#文件服务器
function fileserver(){
	echo "start file server :12345"
	cat &amp;lt;&amp;lt;EOF | tee /tmp/fileserver.go | go run /...
    </summary>
  

  </entry>

</feed>


