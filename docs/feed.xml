

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yinhui</title>
  <subtitle>this is yinhui's blog.</subtitle>
  <updated>2022-06-27T16:46:54+08:00</updated>
  <author>
    <name>zhouyinhui</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator>
  <rights> © 2022 zhouyinhui </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Go语言fmt.Printf使用指南</title>
    <link href="http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80fmt.printf%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" rel="alternate" type="text/html" title="Go语言fmt.Printf使用指南" />
    <published>2022-06-27T00:00:00+08:00</published>
  
    <updated>2022-06-27T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80fmt.printf%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <content src="http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80fmt.printf%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      [转载自: https://www.liwenzhou.com/posts/Go/go_fmt/ 并做了一些补充 ]

fmt标准库是我们在学习Go语言过程中接触最早最频繁的一个了，本文介绍了fmt包的一些常用函数。

##fmt

fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。

向外输出

标准库fmt提供了以下几种输出相关函数。

Print

Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。

func Print(a ...interface{}) (n int, err error)
func Printf(format string, a ...interface{}) (n int,...
    </summary>
  

  </entry>

  
  <entry>
    <title>两台服务器之间的文件挂载</title>
    <link href="http://localhost:4000/posts/%E4%B8%A4%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD/" rel="alternate" type="text/html" title="两台服务器之间的文件挂载" />
    <published>2022-06-24T00:00:00+08:00</published>
  
    <updated>2022-06-24T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/%E4%B8%A4%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD/</id>
    <content src="http://localhost:4000/posts/%E4%B8%A4%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="linux" />
    
  

  
    <summary>
      





      在开发过程中,经常会遇到将一台服务器的文件或目录挂载到另外一台服务器上.

下面说说我经常使用的两种方式.

先举例一个简单的应用场景

我的工作环境经常是这样的


  编译服务器: 编译环境, 有编译工具链, 需要将代码编译成x86, arm, powerpc等多种格式, 所以没办法在自己笔记本电脑上编译.
  自己的笔记本电脑: 用VSCode编辑代码, 上网查资料
  调试服务器, 调试时需要调用其它软件提供的提供的接口, 甚至底层软件提供的数据, 调试服务器还可能经常重装系统, 所以调试服务器和编译服务器不能在一台机器上.


┌──────────────────────────┐         ┌──────────────────────────┐
│      compile server      │         │ running and debug se...
    </summary>
  

  </entry>

  
  <entry>
    <title>golang GetHashCode</title>
    <link href="http://localhost:4000/posts/golang-gethashcode/" rel="alternate" type="text/html" title="golang GetHashCode" />
    <published>2022-06-23T00:00:00+08:00</published>
  
    <updated>2022-06-23T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/golang-gethashcode/</id>
    <content src="http://localhost:4000/posts/golang-gethashcode/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      一个简单的helper函数

package helpers

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
)

func GetHashCode(i interface{}) string {
	s := GetHashCodeHex(i)
	return hex.EncodeToString(s[:])
}

func GetHashCodeHex(i interface{}) [32]byte {
	j, err := json.Marshal(i)
	if err != nil {
		panic("can not Marshal")
	}

	return sha256.Sum256(j)
}




  缺陷:

  对于结构体, 生成hashcode时只使用了public字段, 如果同一结构体类型...
    </summary>
  

  </entry>

  
  <entry>
    <title>golang1.18以后slice扩容策略变化</title>
    <link href="http://localhost:4000/posts/golang1.18%E4%BB%A5%E5%90%8Eslice%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5%E5%8F%98%E5%8C%96/" rel="alternate" type="text/html" title="golang1.18以后slice扩容策略变化" />
    <published>2022-06-22T00:00:00+08:00</published>
  
    <updated>2022-06-22T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/golang1.18%E4%BB%A5%E5%90%8Eslice%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5%E5%8F%98%E5%8C%96/</id>
    <content src="http://localhost:4000/posts/golang1.18%E4%BB%A5%E5%90%8Eslice%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5%E5%8F%98%E5%8C%96/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      golang1.18版本以前, 扩容策略:


  当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。


在1.18版本更新之后，slice的扩容策略变为了:


  当原slice容量小于256的时候，新slice容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4



// go@1.17   slice.go

func growslice(et *_type, old slice, cap int) slice {
  
  //....
  newcap := old.cap
	doublecap := newcap + newcap
	if cap &amp;gt; doublecap {
...
    </summary>
  

  </entry>

  
  <entry>
    <title>使用delve对go代码进行调试</title>
    <link href="http://localhost:4000/posts/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/" rel="alternate" type="text/html" title="使用delve对go代码进行调试" />
    <published>2022-06-21T00:00:00+08:00</published>
  
    <updated>2022-06-21T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/</id>
    <content src="http://localhost:4000/posts/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      delve就是go语言的gdb,虽然 gdb也可以调试go程序 (https://go.dev/doc/gdb). 但是, 用gdb调试go程序有这些已知问题:

已知问题


  字符串pretty printing 只对字符串类型触发，而不是对其派生类型。
  运行库的 C 部分缺少类型信息。
  GDB 不理解 Go 的名称资格，并将 “fmt.Print “视为带有”. “的非结构化字面，需要加以引号。它对pkg.(*MyType).Meth形式的方法名反对得更厉害。
  从Go 1.11开始，调试信息默认是压缩的。旧版本的gdb，例如MacOS上默认提供的版本，并不理解压缩。你可以使用go build -ldflags=-compressdwarf=false来生成未压缩的调试信息。(为了方便，你可以把-ldflags选项放在GOFLAGS环境变量中，这样你就不必每次都指定...
    </summary>
  

  </entry>

</feed>


