

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>Yinhui</title>
  <subtitle>this is yinhui's blog.</subtitle>
  <updated>2022-06-15T14:40:55+08:00</updated>
  <author>
    <name>zhouyinhui</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator>
  <rights> © 2022 zhouyinhui </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>golang实现一个简单的事件处理程序</title>
    <link href="http://localhost:4000/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/" rel="alternate" type="text/html" title="golang实现一个简单的事件处理程序" />
    <published>2022-06-14T00:00:00+08:00</published>
  
    <updated>2022-06-15T11:16:58+08:00</updated>
  
    <id>http://localhost:4000/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/</id>
    <content src="http://localhost:4000/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      一个简单的事件处理程序.

demo目录结构

.
├── events
│   └── event.go
├── go.mod
├── main.go
└── user
    └── login.go



event.go

package events

import "sync"

type EventHandler func(event Event, arg interface{})

var lock sync.Mutex

type Event interface {
	Name() string
	Register(EventHandler) error
	Trigger(arg interface{}) error
}

type SimpleEvent struct {
	name     string
	handlers []EventHandler
}

f...
    </summary>
  

  </entry>

  
  <entry>
    <title>go语言中Channel是如何工作的</title>
    <link href="http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" rel="alternate" type="text/html" title="go语言中Channel是如何工作的" />
    <published>2022-06-13T00:00:00+08:00</published>
  
    <updated>2022-06-13T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <content src="http://localhost:4000/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      了解Golang通道的内部工作原理



goroutine(协程)和通道

goroutine是一个轻量级的用户空间线程，由Go运行时管理。它同时执行任务，可能是并行的。

通道是用于goroutine之间的通信。

在这篇文章中，我们将深入了解通道的内部运作和它的发送/接收操作。

缓冲通道

我们先创建一个缓冲通道用于下面的解释。

ch := make(chan int, 3)      


上面的语句创建了一个缓冲通道，最多可以容纳 3 个 int 类型的值。

在底层，make函数 在堆上分配了一个 hchan 结构并返回一个指向它的指针。
以下是 hchan 结构的一些字段及其解释。

![img](./( ../../assets/img/1*wprFXP6zyl8FPC1PhvslsQ.png)

some fields of hchan struct

type...
    </summary>
  

  </entry>

  
  <entry>
    <title>golang http server</title>
    <link href="http://localhost:4000/posts/golang_http_server/" rel="alternate" type="text/html" title="golang http server" />
    <published>2022-06-13T00:00:00+08:00</published>
  
    <updated>2022-06-13T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/golang_http_server/</id>
    <content src="http://localhost:4000/posts/golang_http_server/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      golang 中http server 基础知识.

简单的文件服务器

package main

import (
	"log"
	"net/http"
)

func main() {
	err := http.ListenAndServe(":8080", http.FileServer(http.Dir(".")))
	if err != nil {
		log.Fatal(err)
	}
}


上面这个例子创建了一个以当前目录为站点跟目录的文件服务器,  我一般用这个来作为局域网文件共享.

然后写一个函数放到bash.rc 或zshrc中

#文件服务器
function fileserver(){
	echo "start file server :12345"
	cat &amp;lt;&amp;lt;EOF | tee /tmp/fileserver.go | go run /...
    </summary>
  

  </entry>

  
  <entry>
    <title>聊聊go语言中的sync</title>
    <link href="http://localhost:4000/posts/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/" rel="alternate" type="text/html" title="聊聊go语言中的sync" />
    <published>2022-06-12T00:00:00+08:00</published>
  
    <updated>2022-06-12T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/</id>
    <content src="http://localhost:4000/posts/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/" />
    <author>
      <name>yinhui</name>
    </author>

  
    
    <category term="BlockChain" />
    
    <category term="golang" />
    
  

  
    <summary>
      





      我们将用些简单的例子来尝试golang中sync包的各种有趣的情况

一个简单的DEMO

package main

import "fmt"

var (
	sharedCounter = 0
)

func add(count int) {
	for i := 0; i &amp;lt; count; i++ {
		sharedCounter++
	}
}

func sub(count int) {
	for i := 0; i &amp;lt; count; i++ {
		sharedCounter--
	}
}

func show() {
	fmt.Println(sharedCounter)
}

func main() {
	add(1000000)
	sub(1000000)
	show()
}




程序很简单, 我们用一个共享变量sharedCounter作为一个计数器...
    </summary>
  

  </entry>

</feed>


