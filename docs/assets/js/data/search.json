[
  
  {
    "title": "go语言中Channel是如何工作的",
    "url": "/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/",
    "categories": "BlockChain, golang",
    "tags": "chan",
    "date": "2022-06-13 00:00:00 +0800",
    





    "snippet": "了解Golang通道的内部工作原理goroutine(协程)和通道goroutine是一个轻量级的用户空间线程，由Go运行时管理。它同时执行任务，可能是并行的。通道是用于goroutine之间的通信。在这篇文章中，我们将深入了解通道的内部运作和它的发送/接收操作。缓冲通道我们先创建一个缓冲通道用于下面的解释。ch := make(chan int, 3)      上面的语句创建了一个缓冲通道，最多可以容纳 3 个 int 类型的值。在底层，make函数 在堆上分配了一个 hchan 结构并返回一个指向它的指针。以下是 hchan 结构的一些字段及其解释。![img](./( ../../assets/img/1*wprFXP6zyl8FPC1PhvslsQ.png)some fields of hchan structtype hchan struct { buf      unsafe.Pointer sendx    uint recvx    uint lock     mutex  ...   // other fields}  buf 是一个指向数组的指针，它维护着一个循环队列。  sendx 是数组中发送元素的索引  recvx 是收到的元素在数组中的索引  lock 确保通道的读写是一个原子性的操作非阻塞的发送和接收当通道未满时，我们可以在循环队列的后面插入元素，而不会有阻塞。// G1 sends three elements into the channel, capicity = 3ch &lt;- elem1ch &lt;- elem2ch &lt;- elem3​当通道不是空的时候，我们可以从循环队列的前面接收元素，而不会有阻塞。// G2 receive three elements from the channel, capicity = 3&lt;- ch&lt;- ch&lt;- ch​阻塞在处理goroutine之间的阻塞时，其他字段也很重要。让我们看一下。some fields of hchan struct  recvq (链表)存储试图在通道上读取数据时被阻塞的goroutines。  sendq(链表) 存储试图从通道发送数据时被阻塞的goroutines。  Remember that Both of recq and sendq are linked list.type hchan struct { buf      unsafe.Pointer sendx    uint recvx    uint lock     mutex  sendq    waitq    recvq    waitq  ...   // more fields}type waitq struct {  first *sudog        last  *sudog}// pseudo goroutinetype sudog struct {  g     *g  elem  unsafe.Pointer   next  *sudog        prev  *sudog  ...  c     *hchan}从空信道进行接收当通道为空时，一个接收操作会导致当前的协程被阻塞。所有被阻塞的协程都存储在recvq队列中。  阻塞的是goroutines，但不是OS线程。那么，被阻塞的goroutine何时会被恢复呢？答案是当一个新的goroutine在通道上执行发送操作时。下面是详细情况。  一个新的goroutine将新数据直接复制到第一个等待的goroutine的元素中  第一个等待的goroutine从recvq中弹出。  运行时调度器设置被弹出的goroutine为可运行状态，并将其放在 “运行队列 “中。然后，被阻塞的程序被触发并准备再次运行。在”满”通道上进行发送当通道满了，接下来的发送操作会阻塞各自的goroutine。所有被阻塞的goroutines都存储在sendq队列中。(没有缓冲区或者说缓冲区大小为0的通道, 和缓冲区满了的通道情况一样)直到另一个goroutine的接收，被阻塞的goroutine被恢复。下面是详细情况。  当一个新的goroutine在通道上执行接收操作时，缓冲区的第一个元素被移除  第一个等待的goroutine从sendq弹出。  弹出的goroutine的元素被复制到缓冲区中  运行时调度器设置被弹出的goroutine为可运行状态，并将其放在 “运行队列 “中。然后，被阻塞的程序被触发并准备再次运行。通道是go中一个非常强大和有趣的机制。希望这篇文章能够解释围棋中通道的基本工作原理。参考文章  Diving Deep Into The Golang Channels  Concurrency And Parallelism in Golang  Go a Tale of Concurrency a Beginners Guide另外, 这篇文章也不错  https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/"
  },
  
  {
    "title": "golang http server",
    "url": "/posts/golang_http_server/",
    "categories": "BlockChain, golang",
    "tags": "http",
    "date": "2022-06-13 00:00:00 +0800",
    





    "snippet": "golang 中http server 基础知识.简单的文件服务器package mainimport (\t\"log\"\t\"net/http\")func main() {\terr := http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\".\")))\tif err != nil {\t\tlog.Fatal(err)\t}}上面这个例子创建了一个以当前目录为站点跟目录的文件服务器,  我一般用这个来作为局域网文件共享.然后写一个函数放到bash.rc 或zshrc中#文件服务器function fileserver(){\techo \"start file server :12345\"\tcat &lt;&lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.gopackage mainimport (\t\"log\"\t\"net/http\")func main() {\terr := http.ListenAndServe(\":12345\", http.FileServer(http.Dir(\".\")))\tif err != nil {\t\tlog.Fatal(err)\t}}EOF}OSX MP16 ~/Downloads ❯ fileserver                                                         start file server :12345Python中有相同的功能python3 -m SimpleHTTPServer 7777  或 python3 -m http.server一个简单的WebServerpackage mainimport (\t\"log\"\t\"net/http\")func main() {\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\t\t_, err := w.Write([]byte(\"Hello World!\\n\"))\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\t})\terr := http.ListenAndServe(\":12345\", nil)\tif err != nil {\t\tlog.Fatal(err)\t}}访问一下试试:OSX MP16 ~/Downloads/goplayground ❯ curl http://localhost:12345          Hello World!http.HandleFunchttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\t\t//...\t})该方法提供了一种指定如何处理特定路由的请求的方法, 第一个参数为路由, 第二个参数为处理函数. 处理函数可写成匿名函数, 也可以声明为一个独立的函数func rootHandler(w http.ResponseWriter, r *http.Request) {\t_, err := w.Write([]byte(\"&lt;h1 style=\\\"color:Tomato;\\\"&gt;Hello World&lt;/h1&gt;\"))\tif err != nil {\t\tlog.Println(err)\t}}func main() {\thttp.HandleFunc(\"/\", rootHandler)  //...}函数的第一个参数是http.ResponseWriter类型的值。这是用于向任何连接的HTTP客户端发送响应的机制。这也是响应标头的设置方式,比如w.WriteHeader(http.StatusOK)。第二个论点是指向http.Request的指针。这是从网络请求中检索数据的方式。例如，可以通过请求指针访问表单提交的详细信息比如 下面的方法, 使用 http://127.0.0.1:12345/?key=date 时将返回当前的日期, 确实key=或key不正确时返回http.StatusBadRequestfunc rootHandler(w http.ResponseWriter, r *http.Request) {\tkeys, ok := r.URL.Query()[\"key\"]\tif !ok || len(keys[0]) &lt; 1 {\t\tlog.Println(\"Url Param 'key' is missing\")\t\tw.WriteHeader(http.StatusBadRequest)\t\t_, err := w.Write([]byte(\"Url Param 'key' is missing\"))\t\tif err != nil {\t\t\tlog.Println(err)\t\t\treturn\t\t}\t\treturn\t}\tkey := keys[0]\tswitch key {\tcase \"date\":\t\tw.WriteHeader(http.StatusOK)\t\t_, err := w.Write([]byte(time.Now().Format(\"2006-01-02\")))\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\tdefault:\t\tw.WriteHeader(http.StatusBadRequest)\t\t_, _ = w.Write([]byte(\"Invalid key\"))\t\tlog.Println(\"Invalid key\")\t}}http.ResponseWriter用于向任何连接的HTTP客户端发送响应设置相应标志头:   w.WriteHeader(http.StatusOK)获取或实则响应头   w.Header().Set(\"content-type\", \"application/json\")   w.Header().Add(\"foo\", \"bar\")写入相应数据:   w.Write([]byte(time.Now().Format(\"2006-01-02\")))例子:package mainimport (\t\"encoding/json\"\t\"log\"\t\"net/http\")type SystemInfo struct {\tHostname string `json:\"hostname\"`\tUptime   string `json:\"uptime\"`}func rootHandler(w http.ResponseWriter, r *http.Request) {\tinfo := SystemInfo{\t\tHostname: \"test\",\t\tUptime:   \"2022-01-01 00:00:00\",\t}\tw.Header().Set(\"Content-Type\", \"application/json\")\tw.WriteHeader(http.StatusOK)\tbytes, _ := json.Marshal(info)\t_, err := w.Write(bytes)\tif err != nil {\t\tlog.Println(\"Error writing response: \", err)\t}}func main() {\thttp.HandleFunc(\"/\", rootHandler)\terr := http.ListenAndServe(\":12345\", nil)\tif err != nil {\t\tlog.Fatal(err)\t}}OSX MP16 ~ ❯ curl localhost:12345                                                         {\"hostname\":\"test\",\"uptime\":\"2022-01-01 00:00:00\"}*http.Request指向http.Request的指针, 通过改指针可以获取请求中的各种数据, 比如获取基本信息func rootHandler(w http.ResponseWriter, r *http.Request) {\tfmt.Println(\"User Agent: \", r.UserAgent())\tfmt.Println(\"Host: \", r.Host)\tfmt.Println(\"Remote Address: \", r.RemoteAddr)\tfmt.Println(\"Request URI: \", r.RequestURI)\tfmt.Println(\"Method: \", r.Method)\tfmt.Println(\"URL: \", r.URL)\tfmt.Println(\"Header: \", r.Header)\tw.WriteHeader(http.StatusOK)}输出:User Agent:  curl/7.79.1Host:  localhost:12345Remote Address:  127.0.0.1:58967Request URI:  /Method:  GETURL:  /Header:  map[Accept:[*/*] User-Agent:[curl/7.79.1]]获取cookiefunc rootHandler(w http.ResponseWriter, r *http.Request) {\t//获取所有\tfor _, c := range r.Cookies() {\t\tfmt.Printf(\"%s : %q\\n\", c.Name, c.Value)\t}\t//获取指定\tc, err := r.Cookie(\"token\")\tif err != nil {\t\tlog.Println(err)\t}\tfmt.Printf(\"%s : %q\\n\", c.Name, c.Value)\tw.WriteHeader(http.StatusOK)}curl --cookie \"token=abcdefg\" http://localhost:12345获取GET参数      获取所有参数 args := r.URL.Query()        获取指定参数(注:参数可能被重复写多次)    比如: localhost:12345/?id=5    func rootHandler(w http.ResponseWriter, r *http.Request) {\tids, ok := r.URL.Query()[\"id\"]\tif !ok || len(ids[0]) &lt; 1 {\t\tlog.Println(\"Url Param 'id' is missing\")\t\treturn\t}\tid := ids[0]\tlog.Println(\"Url Param 'id' is: \" + id)  \t\tw.WriteHeader(http.StatusOK)}      或者func rootHandler(w http.ResponseWriter, r *http.Request) {\tid := r.FormValue(\"id\")\tif id == \"\" {\t\tlog.Println(\"Url Param 'id' is missing\")\t}\tfmt.Println(\"id:\", id)\tw.WriteHeader(http.StatusOK)}  也可以通过r.Form来获取Get参数获取PATCH, POST or PUT参数比如 curl -d \"id=5&amp;format=1\" http://localhost:12345/func rootHandler(w http.ResponseWriter, r *http.Request) {\t//parse\terr := r.ParseForm()\tif err != nil {\t\tlog.Println(\"ParseForm error:\", err)\t}\t//get post args\tfor k, v := range r.PostForm {\t\tlog.Println(\"key:\", k)\t\tlog.Println(\"val:\", v) // v []string\t}\tw.WriteHeader(http.StatusOK)}输出2022/06/06 15:14:46 key: id2022/06/06 15:14:46 val: [5]2022/06/06 15:14:46 key: format2022/06/06 15:14:46 val: [1]ParseForm会填充r.Form和r.PostForm。对于所有的请求，ParseForm解析来自URL的原始查询并更新r.Form。对于POST、PUT和PATCH请求，它也读取请求正文，将其解析为一个表单，并将结果放入r.PostForm和r.Form中。在r.Form中，请求正文参数优先于URL查询字符串值。如果请求体的大小还没有被MaxBytesReader限制，那么其大小将被限制在10MB。对于其他HTTP方法，或者当内容类型不是application/x-www-form-urlencoded时，请求正文不被读取，并且r.PostForm被初始化为一个非零的空值。ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。  r.Form属性包含了post表单和url中的get参数。  r.PostForm属性只包含了post表单参数。获取指定参数, 比如func rootHandler(w http.ResponseWriter, r *http.Request) {\terr := r.ParseForm()\tif err != nil {\t\tlog.Println(\"ParseForm error:\", err)\t}\tids := r.PostForm.Get(\"id\") //获取id参数的第一个值\tlog.Println(\"id:\", ids)\tw.WriteHeader(http.StatusOK)}或者func rootHandler(w http.ResponseWriter, r *http.Request) {\tid := r.PostFormValue(\"id\")\tif id == \"\" {\t\tlog.Println(\"Url Param 'id' is missing\")\t}\tfmt.Println(\"id:\", id)\tw.WriteHeader(http.StatusOK)}获取上传文件比如 curl -F \"file=@IMG_1526.PNG;type=image/png\" http://localhost:12345/upload下面代码中:r.ParseMultipartForm(10 &lt;&lt; 20)将一个请求体解析为multipart/form-data。整个请求正文被解析，并且其文件部分最多存储在maxMemory字节的内存中，其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。如果ParseForm返回一个错误，ParseMultipartForm将其返回，但也继续解析请求正文。在对ParseMultipartForm进行一次调用后，随后的调用没有任何影响.FormFile 返回提供的表单key的第一个文件。如果需要，FormFile会调用ParseMultipartForm和ParseForm。package mainimport (\t\"io\"\t\"log\"\t\"mime/multipart\"\t\"net/http\"\t\"os\")func uploadHandler(w http.ResponseWriter, r *http.Request) {\t// Parse the multipart form in the request\terr := r.ParseMultipartForm(10 &lt;&lt; 20) // 10 MiB\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\t\t\t// FormFile returns the first file for the given key `file`\t// it also returns the FileHeader, so we can get the Filename, the Header and the size of the file\tfile, handler, err := r.FormFile(\"file\")\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\tdefer func(file multipart.File) {\t\terr := file.Close()\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\t}(file)\terr = os.MkdirAll(\"./upload\", 0777)\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\tlocalFile, err := os.OpenFile(\"./upload/\"+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\tdefer func(localFile *os.File) {\t\terr := localFile.Close()\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\t}(localFile)\t_, err = io.Copy(localFile, file)\tif err != nil {\t\thttp.Error(w, \"\", http.StatusInternalServerError)    return\t}\tw.WriteHeader(http.StatusOK)}func main() {\thttp.HandleFunc(\"/upload\", uploadHandler)\terr := http.ListenAndServe(\":12345\", nil)\tif err != nil {\t\tlog.Fatal(err)\t}}👍各种获取参数方式比较            操作      解析      读取URL参数      读取Body表单      支持文本      支持二进制                  r.Form      r.ParseForm()      Y      Y      Y                     r.PostForm      r.ParseForm()             Y      Y                     r.FormValue()      自动调用r.ParseForm()      Y      Y      Y                     r.PostFormValue()      自动调用r.ParseForm()             Y      Y                     r.MultipartForm      ParseMultipartForm()             Y      Y      Y              r.FormFile      自动调用ParseMultipartForm()             Y             Y      Handler , Handle , HandleFunc 与 http.ListenAndServe使用默认的Handler先看一个简单的例子package mainimport \"net/http\"func main() {\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\t\tw.Write([]byte(\"Hello, world!\"))\t})\thttp.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) {\t\tw.Write([]byte(\"This is my Blog\"))\t})\thttp.ListenAndServe(\":12345\", nil)}在启动一个HttpServer的时候, 其实我们就关心2个东西:  地址  路由: 将请求对应到相应的处理函数中去这两个参数 在http.ListenAndServe(\":12345\", nil)中进行设置的, 第一个为地址, 第二个传递处理函数.如果传递nil, 则采用默认的  The handler is typically nil, in which case the DefaultServeMux is used.http.ListenAndServe的实现如下:func ListenAndServe(addr string, handler Handler) error {\tserver := &amp;Server{Addr: addr, Handler: handler}\treturn server.ListenAndServe()}type Handler interface {   ServeHTTP(ResponseWriter, *Request)}可以看到 Handler是一个接口, 实现这个接口的话, 我们可以创建自己的Handler自定义Handler定义一个结构体, 结构体实现 ServeHTTP(w http.ResponseWriter, r *http.Request)方法然后使用 Handle函数进行路由注册package mainimport \"net/http\"type MyIndexHandler struct {}func (h *MyIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\tw.Write([]byte(\"Hello World\"))}type MyBlogHandler struct {}func (h *MyBlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\tw.Write([]byte(\"This is my Blog\"))}func main() {\tmux := http.NewServeMux()\tmux.Handle(\"/\", &amp;MyIndexHandler{})\tmux.Handle(\"/blog\", &amp;MyBlogHandler{})\thttp.ListenAndServe(\":12345\", mux)}OSX MP16 ~ ❯ curl localhost:12345                                                          Hello WorldOSX MP16 ~ ❯ curl localhost:12345/blog                                                     This is my BlogOSX MP16 ~ ❯但这明显看出来, 对每一个路由 都要高写一个xxxHandler结构体和实现ServeHTTP, 看上去非常混乱这时候就可以用mux.HandleFunc来实现路由package mainimport \"net/http\"func main() {   mux := http.NewServeMux()   mux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {      w.Write([]byte(\"Hello World\"))   })   mux.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) {      w.Write([]byte(\"This is my Blog\"))   })   http.ListenAndServe(\":12345\", mux)}自定义ServeMux在上面的例子中, mux := http.NewServeMux()还是使用了默认router, 其简单的同时也有不少缺点比如, 其是通过url进行路由, 但不支持基于方法(GET, POST…)的路由, 不支持正则表达式等等参考这个 https://www.alexedwards.net/blog/which-go-router-should-i-use人气Web框架参考这篇文章,https://blog.51cto.com/coderaction/3001008其中有各框架的对比, 功能上iris最全https://github.com/kataras/iris"
  }
  
]

