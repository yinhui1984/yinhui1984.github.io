[
  
  {
    "title": "golang GetHashCode",
    "url": "/posts/golang-gethashcode/",
    "categories": "BlockChain, golang",
    "tags": "hash",
    "date": "2022-06-23 00:00:00 +0800",
    





    "snippet": "一个简单的helper函数package helpersimport (\t\"crypto/sha256\"\t\"encoding/hex\"\t\"encoding/json\")func GetHashCode(i interface{}) string {\ts := GetHashCodeHex(i)\treturn hex.EncodeToString(s[:])}func GetHashCodeHex(i interface{}) [32]byte {\tj, err := json.Marshal(i)\tif err != nil {\t\tpanic(\"can not Marshal\")\t}\treturn sha256.Sum256(j)}  缺陷:  对于结构体, 生成hashcode时只使用了public字段, 如果同一结构体类型的两个对象只有private字段不同, 那么其生成的hashcode是一样的测试:package main_testimport (\t\"goplayground/helpers\"\t\"testing\")func TestGetHashCode(t *testing.T) {\tt.Run(\"基本类型测试\", func(t *testing.T) {\t\tt.Helper()\t\t_ = helpers.GetHashCode(1)\t\t_ = helpers.GetHashCode(1.23)\t\t_ = helpers.GetHashCode(\"abc\")\t\tif helpers.GetHashCode(\"123456\") != helpers.GetHashCode(\"123456\") {\t\t\tt.Error(\"相同字面量,应该有相同hash\")\t\t}\t})\tt.Run(\"nil测试\", func(t *testing.T) {\t\tt.Helper()\t\tif helpers.GetHashCode(nil) != helpers.GetHashCode(nil) {\t\t\tt.Error(\"nil应该有相同hash\")\t\t}\t})\tt.Run(\"map测试\", func(t *testing.T) {\t\tt.Helper()\t\tm1 := make(map[int]string)\t\tm1[0] = \"hi\"\t\tm1[1] = \"world\"\t\tm2 := make(map[int]string)\t\tm2[0] = \"hi\"\t\tm2[1] = \"world\"\t\tif helpers.GetHashCode(m1) != helpers.GetHashCode(m2) {\t\t\tt.Error(\"相同map应该有相同hash\")\t\t}\t\tm3 := make(map[int]string)\t\tm3[0] = \"hello\"\t\tm3[1] = \"world\"\t\tif helpers.GetHashCode(m1) == helpers.GetHashCode(m3) {\t\t\tt.Error(\"不同map应该有不同hash\")\t\t}\t})\tt.Run(\"结构体测试\", func(t *testing.T) {\t\tt.Helper()\t\ttype people struct {\t\t\tName string\t\t\tAge  uint\t\t}\t\tp1 := people{}\t\tp2 := people{}\t\tif helpers.GetHashCode(p1) != helpers.GetHashCode(p2) {\t\t\tt.Error(\"相同类型空结构体应该有相同hash\")\t\t}\t\tp3 := people{\t\t\tName: \"zhangSan\",\t\t\tAge:  20,\t\t}\t\tp4 := people{\t\t\tName: \"zhangSan\",\t\t\tAge:  20,\t\t}\t\tif helpers.GetHashCode(p3) != helpers.GetHashCode(p4) {\t\t\tt.Error(\"相同结构体应该有相同hash\")\t\t}\t\tp5 := people{\t\t\tName: \"liSi\",\t\t\tAge:  20,\t\t}\t\tif helpers.GetHashCode(p3) == helpers.GetHashCode(p5) {\t\t\tt.Error(\"不同结构体应该有不同hash\")\t\t}\t})}"
  },
  
  {
    "title": "golang1.18以后slice扩容策略变化",
    "url": "/posts/golang1.18%E4%BB%A5%E5%90%8Eslice%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5%E5%8F%98%E5%8C%96/",
    "categories": "BlockChain, golang",
    "tags": "slice",
    "date": "2022-06-22 00:00:00 +0800",
    





    "snippet": "golang1.18版本以前, 扩容策略:  当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。在1.18版本更新之后，slice的扩容策略变为了:  当原slice容量小于256的时候，新slice容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4// go@1.17   slice.gofunc growslice(et *_type, old slice, cap int) slice {    //....  newcap := old.cap\tdoublecap := newcap + newcap\tif cap &gt; doublecap {\t\tnewcap = cap\t} else {\t\tif old.cap &lt; 1024 {\t\t\tnewcap = doublecap\t\t} else {\t\t\t// Check 0 &lt; newcap to detect overflow\t\t\t// and prevent an infinite loop.\t\t\tfor 0 &lt; newcap &amp;&amp; newcap &lt; cap {\t\t\t\tnewcap += newcap / 4\t\t\t}\t\t\t// Set newcap to the requested cap when\t\t\t// the newcap calculation overflowed.\t\t\tif newcap &lt;= 0 {\t\t\t\tnewcap = cap\t\t\t}\t\t}\t}    //....  }// go 1.18 slice.gofunc growslice(et *_type, old slice, cap int) slice {    // ……    newcap := old.cap\tdoublecap := newcap + newcap\tif cap &gt; doublecap {\t\tnewcap = cap\t} else {\t\tconst threshold = 256\t\tif old.cap &lt; threshold {\t\t\tnewcap = doublecap\t\t} else {\t\t\tfor 0 &lt; newcap &amp;&amp; newcap &lt; cap {                // Transition from growing 2x for small slices\t\t\t\t// to growing 1.25x for large slices. This formula\t\t\t\t// gives a smooth-ish transition between the two.\t\t\t\tnewcap += (newcap + 3*threshold) / 4\t\t\t}\t\t\tif newcap &lt;= 0 {\t\t\t\tnewcap = cap\t\t\t}\t\t}\t}\t// ……    }可以通过下面的demo程序来看扩容变化package mainimport \"fmt\"func main() {\ts := make([]int, 0)\toldCap := cap(s)\tfor i := 0; i &lt; 2048; i++ {\t\ts = append(s, i)\t\tcurrentCap := cap(s)\t\tif oldCap != currentCap {\t\t\tfmt.Printf(\"current cap: %d\\n\", currentCap)\t\t\toldCap = currentCap\t\t}\t}}"
  },
  
  {
    "title": "使用delve对go代码进行调试",
    "url": "/posts/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/",
    "categories": "BlockChain, golang",
    "tags": "delve, debug",
    "date": "2022-06-21 00:00:00 +0800",
    





    "snippet": "delve就是go语言的gdb,虽然 gdb也可以调试go程序 (https://go.dev/doc/gdb). 但是, 用gdb调试go程序有这些已知问题:已知问题  字符串pretty printing 只对字符串类型触发，而不是对其派生类型。  运行库的 C 部分缺少类型信息。  GDB 不理解 Go 的名称资格，并将 “fmt.Print “视为带有”. “的非结构化字面，需要加以引号。它对pkg.(*MyType).Meth形式的方法名反对得更厉害。  从Go 1.11开始，调试信息默认是压缩的。旧版本的gdb，例如MacOS上默认提供的版本，并不理解压缩。你可以使用go build -ldflags=-compressdwarf=false来生成未压缩的调试信息。(为了方便，你可以把-ldflags选项放在GOFLAGS环境变量中，这样你就不必每次都指定它)。使用 delve  https://github.com/go-delve/delve 更简单舒适首次安装go install github.com/go-delve/delve/cmd/dlv@latest基本使用  如果是调试主程序, cd到main.go所在目录, 运行 dlv debug  如果是调试测试代码,  cd到*_test.go所在目录, 运行 dlv test然后 和 gdb用法类似  break: 打断点 b packageName.functionName  或 b fileName:lineNumber比如 b main.Add,  b main.main  continue: 开始执行或继续执行 c   (开始执行也用c)  next :执行下一行 n  step: 单步进入 s  stepout: 单步退出so  print:打印 p thevar   quit退出调试 q更多的  https://github.com/go-delve/delve/blob/master/Documentation/cli/README.md高级使用dlv attach - 附加到正在运行的进程并开始调试。dlv connect - 用终端客户端连接到headless debug server。dlv core - 检查一个核心转储。dlv dap - 启动一个通过调试适配器协议（DAP）通信的无头TCP服务器。dlv debug - 编译并开始调试当前目录下的主包，或指定的包。dlv exec - 执行一个预编译的二进制文件，并开始一个调试会话。dlv replay - 回放一个rr跟踪。dlv run - 废弃的命令。使用’debug’代替。dlv test - 编译测试二进制文件并开始调试程序。dlv trace - 编译并开始追踪程序。dlv version - 打印版本。dlv log - 关于记录标记的帮助dlv backend -  --backend flag的帮助"
  },
  
  {
    "title": "golang实现一个简单的事件处理程序",
    "url": "/posts/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/",
    "categories": "BlockChain, golang",
    "tags": "event",
    "date": "2022-06-14 00:00:00 +0800",
    





    "snippet": "一个简单的事件处理程序.demo目录结构.├── events│   └── event.go├── go.mod├── main.go└── user    └── login.goevent.gopackage eventsimport \"sync\"type EventHandler func(event Event, arg interface{})var lock sync.Mutextype Event interface {\tName() string\tRegister(EventHandler) error\tTrigger(arg interface{}) error}type SimpleEvent struct {\tname     string\thandlers []EventHandler}func (e SimpleEvent) Name() string {\treturn e.name}func (e *SimpleEvent) Register(h EventHandler) error {\tlock.Lock()\te.handlers = append(e.handlers, h)\tlock.Unlock()\treturn nil}func (e *SimpleEvent) Trigger(arg interface{}) error {\tlock.Lock()\tfor _, h := range e.handlers {\t\tgo h(e, arg)\t}\tlock.Unlock()\treturn nil}func NewSimpleEvent(name string) Event {\treturn &amp;SimpleEvent{name: name}}demologin.go模拟登录登出的时候,发送事件package userimport (\t\"goplayground/events\"\t\"time\")var (\tLoginEvent  = events.NewSimpleEvent(\"user.login\")\tLogoutEvent = events.NewSimpleEvent(\"user.logout\"))type LoginArg struct {\tUsername string\tPassword string\tTime     time.Time}type LogoutArg struct {\tUsername string\tTime     time.Time}func Login(username, password string) (bool, error) {\t_ = LoginEvent.Trigger(LoginArg{username, password, time.Now()})\treturn true, nil}func Logout(username string) error {\t_ = LogoutEvent.Trigger(LogoutArg{username, time.Now()})\treturn nil}main.gopackage mainimport (\t\"fmt\"\t\"goplayground/events\"\t\"goplayground/user\"\t\"time\")func main() {\t//事件处理程序 注册\tuser.LoginEvent.Register(func(event events.Event, arg interface{}) {\t\ta := arg.(user.LoginArg)\t\tfmt.Printf(\"%q: %q %q %q\\n\", event.Name(), a.Username, a.Password, a.Time)\t})\tuser.LogoutEvent.Register(func(event events.Event, arg interface{}) {\t\ta := arg.(user.LogoutArg)\t\tfmt.Printf(\"%q: %q %q\\n\", event.Name(), a.Username, a.Time)\t})\t//模拟\tuser.Login(\"admin\", \"admin\")\ttime.Sleep(time.Second)\tuser.Logout(\"admin\")\ttime.Sleep(time.Second)}"
  },
  
  {
    "title": "go语言中Channel是如何工作的",
    "url": "/posts/go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/",
    "categories": "BlockChain, golang",
    "tags": "chan",
    "date": "2022-06-13 00:00:00 +0800",
    





    "snippet": "了解Golang通道的内部工作原理goroutine(协程)和通道goroutine是一个轻量级的用户空间线程，由Go运行时管理。它同时执行任务，可能是并行的。通道是用于goroutine之间的通信。在这篇文章中，我们将深入了解通道的内部运作和它的发送/接收操作。缓冲通道我们先创建一个缓冲通道用于下面的解释。ch := make(chan int, 3)      上面的语句创建了一个缓冲通道，最多可以容纳 3 个 int 类型的值。在底层，make函数 在堆上分配了一个 hchan 结构并返回一个指向它的指针。以下是 hchan 结构的一些字段及其解释。![img](./( ../../assets/img/1*wprFXP6zyl8FPC1PhvslsQ.png)some fields of hchan structtype hchan struct { buf      unsafe.Pointer sendx    uint recvx    uint lock     mutex  ...   // other fields}  buf 是一个指向数组的指针，它维护着一个循环队列。  sendx 是数组中发送元素的索引  recvx 是收到的元素在数组中的索引  lock 确保通道的读写是一个原子性的操作非阻塞的发送和接收当通道未满时，我们可以在循环队列的后面插入元素，而不会有阻塞。// G1 sends three elements into the channel, capicity = 3ch &lt;- elem1ch &lt;- elem2ch &lt;- elem3​当通道不是空的时候，我们可以从循环队列的前面接收元素，而不会有阻塞。// G2 receive three elements from the channel, capicity = 3&lt;- ch&lt;- ch&lt;- ch​阻塞在处理goroutine之间的阻塞时，其他字段也很重要。让我们看一下。some fields of hchan struct  recvq (链表)存储试图在通道上读取数据时被阻塞的goroutines。  sendq(链表) 存储试图从通道发送数据时被阻塞的goroutines。  Remember that Both of recq and sendq are linked list.type hchan struct { buf      unsafe.Pointer sendx    uint recvx    uint lock     mutex  sendq    waitq    recvq    waitq  ...   // more fields}type waitq struct {  first *sudog        last  *sudog}// pseudo goroutinetype sudog struct {  g     *g  elem  unsafe.Pointer   next  *sudog        prev  *sudog  ...  c     *hchan}从空信道进行接收当通道为空时，一个接收操作会导致当前的协程被阻塞。所有被阻塞的协程都存储在recvq队列中。  阻塞的是goroutines，但不是OS线程。那么，被阻塞的goroutine何时会被恢复呢？答案是当一个新的goroutine在通道上执行发送操作时。下面是详细情况。  一个新的goroutine将新数据直接复制到第一个等待的goroutine的元素中  第一个等待的goroutine从recvq中弹出。  运行时调度器设置被弹出的goroutine为可运行状态，并将其放在 “运行队列 “中。然后，被阻塞的程序被触发并准备再次运行。在”满”通道上进行发送当通道满了，接下来的发送操作会阻塞各自的goroutine。所有被阻塞的goroutines都存储在sendq队列中。(没有缓冲区或者说缓冲区大小为0的通道, 和缓冲区满了的通道情况一样)直到另一个goroutine的接收，被阻塞的goroutine被恢复。下面是详细情况。  当一个新的goroutine在通道上执行接收操作时，缓冲区的第一个元素被移除  第一个等待的goroutine从sendq弹出。  弹出的goroutine的元素被复制到缓冲区中  运行时调度器设置被弹出的goroutine为可运行状态，并将其放在 “运行队列 “中。然后，被阻塞的程序被触发并准备再次运行。通道是go中一个非常强大和有趣的机制。希望这篇文章能够解释围棋中通道的基本工作原理。参考文章  Diving Deep Into The Golang Channels  Concurrency And Parallelism in Golang  Go a Tale of Concurrency a Beginners Guide另外, 这篇文章也不错  https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/"
  },
  
  {
    "title": "golang http server",
    "url": "/posts/golang_http_server/",
    "categories": "BlockChain, golang",
    "tags": "http",
    "date": "2022-06-13 00:00:00 +0800",
    





    "snippet": "golang 中http server 基础知识.简单的文件服务器package mainimport (\t\"log\"\t\"net/http\")func main() {\terr := http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\".\")))\tif err != nil {\t\tlog.Fatal(err)\t}}上面这个例子创建了一个以当前目录为站点跟目录的文件服务器,  我一般用这个来作为局域网文件共享.然后写一个函数放到bash.rc 或zshrc中#文件服务器function fileserver(){\techo \"start file server :12345\"\tcat &lt;&lt;EOF | tee /tmp/fileserver.go | go run /tmp/fileserver.gopackage mainimport (\t\"log\"\t\"net/http\")func main() {\terr := http.ListenAndServe(\":12345\", http.FileServer(http.Dir(\".\")))\tif err != nil {\t\tlog.Fatal(err)\t}}EOF}OSX MP16 ~/Downloads ❯ fileserver                                                         start file server :12345Python中有相同的功能python3 -m SimpleHTTPServer 7777  或 python3 -m http.server一个简单的WebServerpackage mainimport (\t\"log\"\t\"net/http\")func main() {\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\t\t_, err := w.Write([]byte(\"Hello World!\\n\"))\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\t})\terr := http.ListenAndServe(\":12345\", nil)\tif err != nil {\t\tlog.Fatal(err)\t}}访问一下试试:OSX MP16 ~/Downloads/goplayground ❯ curl http://localhost:12345          Hello World!http.HandleFunchttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\t\t//...\t})该方法提供了一种指定如何处理特定路由的请求的方法, 第一个参数为路由, 第二个参数为处理函数. 处理函数可写成匿名函数, 也可以声明为一个独立的函数func rootHandler(w http.ResponseWriter, r *http.Request) {\t_, err := w.Write([]byte(\"&lt;h1 style=\\\"color:Tomato;\\\"&gt;Hello World&lt;/h1&gt;\"))\tif err != nil {\t\tlog.Println(err)\t}}func main() {\thttp.HandleFunc(\"/\", rootHandler)  //...}函数的第一个参数是http.ResponseWriter类型的值。这是用于向任何连接的HTTP客户端发送响应的机制。这也是响应标头的设置方式,比如w.WriteHeader(http.StatusOK)。第二个论点是指向http.Request的指针。这是从网络请求中检索数据的方式。例如，可以通过请求指针访问表单提交的详细信息比如 下面的方法, 使用 http://127.0.0.1:12345/?key=date 时将返回当前的日期, 确实key=或key不正确时返回http.StatusBadRequestfunc rootHandler(w http.ResponseWriter, r *http.Request) {\tkeys, ok := r.URL.Query()[\"key\"]\tif !ok || len(keys[0]) &lt; 1 {\t\tlog.Println(\"Url Param 'key' is missing\")\t\tw.WriteHeader(http.StatusBadRequest)\t\t_, err := w.Write([]byte(\"Url Param 'key' is missing\"))\t\tif err != nil {\t\t\tlog.Println(err)\t\t\treturn\t\t}\t\treturn\t}\tkey := keys[0]\tswitch key {\tcase \"date\":\t\tw.WriteHeader(http.StatusOK)\t\t_, err := w.Write([]byte(time.Now().Format(\"2006-01-02\")))\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\tdefault:\t\tw.WriteHeader(http.StatusBadRequest)\t\t_, _ = w.Write([]byte(\"Invalid key\"))\t\tlog.Println(\"Invalid key\")\t}}http.ResponseWriter用于向任何连接的HTTP客户端发送响应设置相应标志头:   w.WriteHeader(http.StatusOK)获取或实则响应头   w.Header().Set(\"content-type\", \"application/json\")   w.Header().Add(\"foo\", \"bar\")写入相应数据:   w.Write([]byte(time.Now().Format(\"2006-01-02\")))例子:package mainimport (\t\"encoding/json\"\t\"log\"\t\"net/http\")type SystemInfo struct {\tHostname string `json:\"hostname\"`\tUptime   string `json:\"uptime\"`}func rootHandler(w http.ResponseWriter, r *http.Request) {\tinfo := SystemInfo{\t\tHostname: \"test\",\t\tUptime:   \"2022-01-01 00:00:00\",\t}\tw.Header().Set(\"Content-Type\", \"application/json\")\tw.WriteHeader(http.StatusOK)\tbytes, _ := json.Marshal(info)\t_, err := w.Write(bytes)\tif err != nil {\t\tlog.Println(\"Error writing response: \", err)\t}}func main() {\thttp.HandleFunc(\"/\", rootHandler)\terr := http.ListenAndServe(\":12345\", nil)\tif err != nil {\t\tlog.Fatal(err)\t}}OSX MP16 ~ ❯ curl localhost:12345                                                         {\"hostname\":\"test\",\"uptime\":\"2022-01-01 00:00:00\"}*http.Request指向http.Request的指针, 通过改指针可以获取请求中的各种数据, 比如获取基本信息func rootHandler(w http.ResponseWriter, r *http.Request) {\tfmt.Println(\"User Agent: \", r.UserAgent())\tfmt.Println(\"Host: \", r.Host)\tfmt.Println(\"Remote Address: \", r.RemoteAddr)\tfmt.Println(\"Request URI: \", r.RequestURI)\tfmt.Println(\"Method: \", r.Method)\tfmt.Println(\"URL: \", r.URL)\tfmt.Println(\"Header: \", r.Header)\tw.WriteHeader(http.StatusOK)}输出:User Agent:  curl/7.79.1Host:  localhost:12345Remote Address:  127.0.0.1:58967Request URI:  /Method:  GETURL:  /Header:  map[Accept:[*/*] User-Agent:[curl/7.79.1]]获取cookiefunc rootHandler(w http.ResponseWriter, r *http.Request) {\t//获取所有\tfor _, c := range r.Cookies() {\t\tfmt.Printf(\"%s : %q\\n\", c.Name, c.Value)\t}\t//获取指定\tc, err := r.Cookie(\"token\")\tif err != nil {\t\tlog.Println(err)\t}\tfmt.Printf(\"%s : %q\\n\", c.Name, c.Value)\tw.WriteHeader(http.StatusOK)}curl --cookie \"token=abcdefg\" http://localhost:12345获取GET参数      获取所有参数 args := r.URL.Query()        获取指定参数(注:参数可能被重复写多次)    比如: localhost:12345/?id=5    func rootHandler(w http.ResponseWriter, r *http.Request) {\tids, ok := r.URL.Query()[\"id\"]\tif !ok || len(ids[0]) &lt; 1 {\t\tlog.Println(\"Url Param 'id' is missing\")\t\treturn\t}\tid := ids[0]\tlog.Println(\"Url Param 'id' is: \" + id)  \t\tw.WriteHeader(http.StatusOK)}      或者func rootHandler(w http.ResponseWriter, r *http.Request) {\tid := r.FormValue(\"id\")\tif id == \"\" {\t\tlog.Println(\"Url Param 'id' is missing\")\t}\tfmt.Println(\"id:\", id)\tw.WriteHeader(http.StatusOK)}  也可以通过r.Form来获取Get参数获取PATCH, POST or PUT参数比如 curl -d \"id=5&amp;format=1\" http://localhost:12345/func rootHandler(w http.ResponseWriter, r *http.Request) {\t//parse\terr := r.ParseForm()\tif err != nil {\t\tlog.Println(\"ParseForm error:\", err)\t}\t//get post args\tfor k, v := range r.PostForm {\t\tlog.Println(\"key:\", k)\t\tlog.Println(\"val:\", v) // v []string\t}\tw.WriteHeader(http.StatusOK)}输出2022/06/06 15:14:46 key: id2022/06/06 15:14:46 val: [5]2022/06/06 15:14:46 key: format2022/06/06 15:14:46 val: [1]ParseForm会填充r.Form和r.PostForm。对于所有的请求，ParseForm解析来自URL的原始查询并更新r.Form。对于POST、PUT和PATCH请求，它也读取请求正文，将其解析为一个表单，并将结果放入r.PostForm和r.Form中。在r.Form中，请求正文参数优先于URL查询字符串值。如果请求体的大小还没有被MaxBytesReader限制，那么其大小将被限制在10MB。对于其他HTTP方法，或者当内容类型不是application/x-www-form-urlencoded时，请求正文不被读取，并且r.PostForm被初始化为一个非零的空值。ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。  r.Form属性包含了post表单和url中的get参数。  r.PostForm属性只包含了post表单参数。获取指定参数, 比如func rootHandler(w http.ResponseWriter, r *http.Request) {\terr := r.ParseForm()\tif err != nil {\t\tlog.Println(\"ParseForm error:\", err)\t}\tids := r.PostForm.Get(\"id\") //获取id参数的第一个值\tlog.Println(\"id:\", ids)\tw.WriteHeader(http.StatusOK)}或者func rootHandler(w http.ResponseWriter, r *http.Request) {\tid := r.PostFormValue(\"id\")\tif id == \"\" {\t\tlog.Println(\"Url Param 'id' is missing\")\t}\tfmt.Println(\"id:\", id)\tw.WriteHeader(http.StatusOK)}获取上传文件比如 curl -F \"file=@IMG_1526.PNG;type=image/png\" http://localhost:12345/upload下面代码中:r.ParseMultipartForm(10 &lt;&lt; 20)将一个请求体解析为multipart/form-data。整个请求正文被解析，并且其文件部分最多存储在maxMemory字节的内存中，其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。如果ParseForm返回一个错误，ParseMultipartForm将其返回，但也继续解析请求正文。在对ParseMultipartForm进行一次调用后，随后的调用没有任何影响.FormFile 返回提供的表单key的第一个文件。如果需要，FormFile会调用ParseMultipartForm和ParseForm。package mainimport (\t\"io\"\t\"log\"\t\"mime/multipart\"\t\"net/http\"\t\"os\")func uploadHandler(w http.ResponseWriter, r *http.Request) {\t// Parse the multipart form in the request\terr := r.ParseMultipartForm(10 &lt;&lt; 20) // 10 MiB\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\t\t\t// FormFile returns the first file for the given key `file`\t// it also returns the FileHeader, so we can get the Filename, the Header and the size of the file\tfile, handler, err := r.FormFile(\"file\")\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\tdefer func(file multipart.File) {\t\terr := file.Close()\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\t}(file)\terr = os.MkdirAll(\"./upload\", 0777)\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\tlocalFile, err := os.OpenFile(\"./upload/\"+handler.Filename, os.O_WRONLY|os.O_CREATE, 0666)\tif err != nil {\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\t\treturn\t}\tdefer func(localFile *os.File) {\t\terr := localFile.Close()\t\tif err != nil {\t\t\tlog.Println(err)\t\t}\t}(localFile)\t_, err = io.Copy(localFile, file)\tif err != nil {\t\thttp.Error(w, \"\", http.StatusInternalServerError)    return\t}\tw.WriteHeader(http.StatusOK)}func main() {\thttp.HandleFunc(\"/upload\", uploadHandler)\terr := http.ListenAndServe(\":12345\", nil)\tif err != nil {\t\tlog.Fatal(err)\t}}👍各种获取参数方式比较            操作      解析      读取URL参数      读取Body表单      支持文本      支持二进制                  r.Form      r.ParseForm()      Y      Y      Y                     r.PostForm      r.ParseForm()             Y      Y                     r.FormValue()      自动调用r.ParseForm()      Y      Y      Y                     r.PostFormValue()      自动调用r.ParseForm()             Y      Y                     r.MultipartForm      ParseMultipartForm()             Y      Y      Y              r.FormFile      自动调用ParseMultipartForm()             Y             Y      Handler , Handle , HandleFunc 与 http.ListenAndServe使用默认的Handler先看一个简单的例子package mainimport \"net/http\"func main() {\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\t\tw.Write([]byte(\"Hello, world!\"))\t})\thttp.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) {\t\tw.Write([]byte(\"This is my Blog\"))\t})\thttp.ListenAndServe(\":12345\", nil)}在启动一个HttpServer的时候, 其实我们就关心2个东西:  地址  路由: 将请求对应到相应的处理函数中去这两个参数 在http.ListenAndServe(\":12345\", nil)中进行设置的, 第一个为地址, 第二个传递处理函数.如果传递nil, 则采用默认的  The handler is typically nil, in which case the DefaultServeMux is used.http.ListenAndServe的实现如下:func ListenAndServe(addr string, handler Handler) error {\tserver := &amp;Server{Addr: addr, Handler: handler}\treturn server.ListenAndServe()}type Handler interface {   ServeHTTP(ResponseWriter, *Request)}可以看到 Handler是一个接口, 实现这个接口的话, 我们可以创建自己的Handler自定义Handler定义一个结构体, 结构体实现 ServeHTTP(w http.ResponseWriter, r *http.Request)方法然后使用 Handle函数进行路由注册package mainimport \"net/http\"type MyIndexHandler struct {}func (h *MyIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\tw.Write([]byte(\"Hello World\"))}type MyBlogHandler struct {}func (h *MyBlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\tw.Write([]byte(\"This is my Blog\"))}func main() {\tmux := http.NewServeMux()\tmux.Handle(\"/\", &amp;MyIndexHandler{})\tmux.Handle(\"/blog\", &amp;MyBlogHandler{})\thttp.ListenAndServe(\":12345\", mux)}OSX MP16 ~ ❯ curl localhost:12345                                                          Hello WorldOSX MP16 ~ ❯ curl localhost:12345/blog                                                     This is my BlogOSX MP16 ~ ❯但这明显看出来, 对每一个路由 都要高写一个xxxHandler结构体和实现ServeHTTP, 看上去非常混乱这时候就可以用mux.HandleFunc来实现路由package mainimport \"net/http\"func main() {   mux := http.NewServeMux()   mux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {      w.Write([]byte(\"Hello World\"))   })   mux.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) {      w.Write([]byte(\"This is my Blog\"))   })   http.ListenAndServe(\":12345\", mux)}自定义ServeMux在上面的例子中, mux := http.NewServeMux()还是使用了默认router, 其简单的同时也有不少缺点比如, 其是通过url进行路由, 但不支持基于方法(GET, POST…)的路由, 不支持正则表达式等等参考这个 https://www.alexedwards.net/blog/which-go-router-should-i-use人气Web框架参考这篇文章,https://blog.51cto.com/coderaction/3001008其中有各框架的对比, 功能上iris最全https://github.com/kataras/iris"
  },
  
  {
    "title": "聊聊go语言中的sync",
    "url": "/posts/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/",
    "categories": "BlockChain, golang",
    "tags": "sync",
    "date": "2022-06-12 00:00:00 +0800",
    





    "snippet": "我们将用些简单的例子来尝试golang中sync包的各种有趣的情况一个简单的DEMOpackage mainimport \"fmt\"var (\tsharedCounter = 0)func add(count int) {\tfor i := 0; i &lt; count; i++ {\t\tsharedCounter++\t}}func sub(count int) {\tfor i := 0; i &lt; count; i++ {\t\tsharedCounter--\t}}func show() {\tfmt.Println(sharedCounter)}func main() {\tadd(1000000)\tsub(1000000)\tshow()}程序很简单, 我们用一个共享变量sharedCounter作为一个计数器. add函数在计数器上循环添加一定的数值, sub则相反, show则是打印计数器当前的值.程序运行结束后, sharedCounter应该为0, 上面代码的输出的确如此.使用一个协程如果对计数器进行加减的调用在不同的协程里面, 会怎么样呢?func main() {\tadd(1000000)\tgo sub(1000000)\tshow()}会得到1000000 , 因为go sub(1000000)刚启动, 程序就退出了.或许我们应该等到sub函数执行结束等待协程结束      错误的方式如果有C语言开发背景, 可能会想到通过设置一个flag来指示运算是否结束, 比如:    func sub(count int, done *bool) {\tfor i := 0; i &lt; count; i++ {\t\tsharedCounter--\t}\t*done = true}//....   func main() {\tadd(1000000)   \tdone := false\tgo sub(1000000, &amp;done)   \tfor !done {\t\ttime.Sleep(time.Millisecond * 10)\t}   \t\tshow()}        这虽然也能得到正确的输出, 但非常不优雅.        正确的方式1可以使用一个无缓冲的信道(或者说容量为1的信道)来充当flag    //...func sub(count int, done chan bool) {\tfor i := 0; i &lt; count; i++ {\t\tsharedCounter--\t}\tdone &lt;- true}//....func main() {\tadd(1000000)   \tdone := make(chan bool)\tgo sub(1000000, done)\t&lt;-subDone\tshow()}        这里利用了信道的特点: 当从信道中读取数据时,如果信道为空,读取将被阻塞直到有数据到达.  所以 &lt;-subDone 会一直阻塞, 直到通过subDone &lt;- true向其中写入了数据  使用2个协程上面的例子中, sub(1000000, done)是在新的协程中运行的, add(1000000)却不是, 如果他们都在新协程中运行, 主程序应该如何等待他们结束呢很容易想到,  使用两次&lt;-done 也就是说向信道索要两个计算完成的标志, add和 sub    计算完成后分别向其中放入标志.package mainimport \"fmt\"var (\tsharedCounter = 0)func add(count int, done chan bool) {\tfor i := 0; i &lt; count; i++ {\t\tsharedCounter++\t}\tfmt.Println(\"add done\")\tdone &lt;- true}func sub(count int, done chan bool) {\tfor i := 0; i &lt; count; i++ {\t\tsharedCounter--\t}\tfmt.Println(\"sub done\")\tdone &lt;- true}func show() {\tfmt.Println(sharedCounter)}func main() {\tdone := make(chan bool)\tgo add(1000000, done)\tgo sub(1000000, done)\t&lt;-done\t&lt;-done\tshow()}为了明确知道main函数的确是等待两个协程执行完毕了的, 我们在其中加入了fmt.Println(\"sub done\")这样的输出运行程序, 得到add donesub done824933Opps, 虽然add和sub 都执行完毕了,但是结果不对(并且多次运行的结果还不相同), 期望接收应该是0再运行一次, 得到:sub doneadd done-481342原因是add和sub在交叉读取和写入sharedCounter这个变量, 他们共享了变量, 但在读取和写入的时候出现“竞态”竞态有多个协程运行时, 对于每个协程而言,其内部代码时顺序执行的, 但无法确定协程之间的执行顺序, 那么就说这些协程是并发的如果一段代码无论是顺序执行还是并发执行,其结果都是确定的,那么这个代码就是并发安全的.相反, 并发不安全的代码,可能会出现死锁,活锁,竞态竞态则表示代码可执行,但可能出现结果不一致(错误结果)###解决方法1, 利用信道func main() {\tdone := make(chan bool)\tgo add(1000000, done)\t&lt;-done //1\tgo sub(1000000, done)\t&lt;-done //2\tshow()}在add执行完毕之前, 首先会堵塞在//1处,func add(count int, done chan bool) {\t//....\tdone &lt;- true}add函数执行最后一句 done &lt;- true  后 &lt;-done //1能取到值, 接触阻塞. 然后继续往下执行sub函数.这虽然能得到正确输出, 但, 我们发现, 这实际是将并行执行修改成了串行执行.解决方法2, 利用 Mutex 或 RWMutexsync.Mutex 可能是同步包中使用最广泛的原语。它允许对共享资源进行互斥（不能同时访问).mutex := &amp;sync.Mutex{}mutex.Lock()//.... 更新共享变量mutex.Unlock()注意: 在官方文档中有这么一句 “Values containing the types defined in this package should not be copied.”   (“包含这个包中定义的类型的值不应该被复制。”) . 我们直到值传递就是复制然后传递, 所以我们代码中的mutex用的是引用传递.package mainimport (\t\"fmt\"\t\"sync\")var (\tsharedCounter = 0\tmutex         = &amp;sync.Mutex{})func add(count int, done chan bool) {\tfor i := 0; i &lt; count; i++ {\t\tmutex.Lock()\t\tsharedCounter++\t\tmutex.Unlock()\t}\tfmt.Println(\"add done\")\tdone &lt;- true}func sub(count int, done chan bool) {\tfor i := 0; i &lt; count; i++ {\t\tmutex.Lock()\t\tsharedCounter--\t\tmutex.Unlock()\t}\tfmt.Println(\"sub done\")\tdone &lt;- true}func show() {\tfmt.Println(sharedCounter)}func main() {\tdone := make(chan bool)\tgo add(1000000, done)\tgo sub(1000000, done)\t&lt;-done\t&lt;-done\tshow()}在读写sharedCounter之前先Lock(), 用完后Unlock()如果我们在进行计算的时候加上点打印(仅测试用,非常影响速度)for i := 0; i &lt; count; i++ {\t\tmutex.Lock()\t\tfmt.Println(\"--\") // fmt.Println(\"++\")\t\tsharedCounter--   // sharedCounter++\t\tmutex.Unlock()\t}则可以看到 ++ 和 – 是交叉着打印的, 说明是并行执行的.另外, 还有RWMutex (读写锁), 除了与Mutex相同的Lock()和Unlock()方法外,  其还有用于共享读操作的RLock()和RUnlock(), 在读取共享变量时允许同时多个读取器能提高效率.  所以在频繁读写操作的代码中, 使用RWMutex效率要比Mutex高解决方法3, 利用原子操作原子操作在\"sync/atomic\"包中. 利用这个包中提供的函数可实现”无锁版”的共享变量读写原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作package mainimport (\t\"fmt\"\t\"sync/atomic\")var (\tsharedCounter = int64(0))func add(count int, done chan bool) {\tfor i := 0; i &lt; count; i++ {\t\tatomic.AddInt64(&amp;sharedCounter, 1) //\t}\tfmt.Println(\"add done\")\tdone &lt;- true}func sub(count int, done chan bool) {\tfor i := 0; i &lt; count; i++ {\t\tatomic.AddInt64(&amp;sharedCounter, -1) //\t}\tfmt.Println(\"sub done\")\tdone &lt;- true}func show() {\tfmt.Println(sharedCounter)}func main() {\tdone := make(chan bool)\tgo add(1000000, done)\tgo sub(1000000, done)\t&lt;-done\t&lt;-done\tshow()}原子操作的常用接口如下(以int32为例)//将addr指向的值和old进行比较, 如果相等,则将new赋值到addr指向的位置,并返回true, 如果不相等,则直接返回falsefunc CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)//使用原子操作,将addr指向的位置增加一个deltafunc AddInt32(addr *int32, delta int32) (new int32)//原子读取//当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。func LoadInt32(addr *int32) (val int32)//读取是有原子性的操作的，同样写入atomic包也提供了相关的操作包func StoreInt32(addr *int32, val int32)//此类型的值相当于一个容器，可以被用来“原子地\"存储（Store）和加载（Load）任意类型的值。当然这个类型也是原子性的。//有了atomic.Value这个类型，这样用户就可以在不依赖Go内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。// A Value must not be copied after first use.type Value struct {\tv interface{}}  原子操作与互斥锁的区别  首先atomic操作的优势是更轻量，比如CAS可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。  原子操作也有劣势。还是以CAS操作为例，使用CAS操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。  下面是几点区别：      互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作    原子操作是无锁的，常常直接通过CPU指令直接实现    原子操作中的cas趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理    可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程    不要轻易使用atomic  https://texlution.com/post/golang-lock-free-values-with-atomic-value/其它并发控制方法上面的例子中, 我们都是使用的信道来进行并发控制 (done &lt;- true与&lt;-done), 这只是常用的方法之一WaitGroupsync.WaitGroup 拥有一个内部计数器。如果此计数器等于 0，则 Wait() 方法立即返回。否则，它将被阻塞，直到计数器为 0。要增加计数器，我们必须使用 Add(int)。要减少它，我们可以使用 Done() （将减少 1）或具有负值的相同 Add(int) 方法。package mainimport (   \"fmt\"   \"sync\"   \"sync/atomic\")var (   sharedCounter = int64(0))func add(count int, wg *sync.WaitGroup) {   for i := 0; i &lt; count; i++ {      atomic.AddInt64(&amp;sharedCounter, 1)   }   fmt.Println(\"add done\")   wg.Done()}func sub(count int, wg *sync.WaitGroup) {   for i := 0; i &lt; count; i++ {      atomic.AddInt64(&amp;sharedCounter, -1)   }   fmt.Println(\"sub done\")   wg.Done()}func show() {   fmt.Println(sharedCounter)}func main() {   wg := sync.WaitGroup{}   wg.Add(2)   go add(1000000, &amp;wg)   go sub(1000000, &amp;wg)   wg.Wait()   show()}注意:传递 WaitGroup时要使用引用传递(指针), 其不应该被复制. func sub(count int, wg *sync.WaitGroup)context.ContextContext提供了2个功能  控制子协程结束  传递值其不在sync包中, 后面专门讲sync.Pool 对象复用其提供一个”并发安全”的可复用的对象池. 用来减少频繁GC所代理的压力.其大概意思是: 如果有旧对象可用,则用旧的, 没有再New一个参考这批文章: https://www.cnblogs.com/qcrao-2018/p/12736031.html以及这里 https://geektutu.com/post/hpg-sync-pool.html在实际开发工作中, 不要一上来就想做使用sync.Pool它通常会带来问题(因为其Get出来的对象的状态是不确定的), 而应该遵循下面的原则:  根据你收集到的需求设计你的代码（不要跳过这个步骤）。  编写最简单、最清晰、最愚蠢的设计实现。  如果客户满意，就停止  如果客户不满意，而且他们认为应用程序的性能不能满足他们的要求，那么就剖析。  解决最高性能的主导者  剖析并进入第五阶段。然后进入3  如果实在搞不定, 再想想sync.Poolsync.Once 只执行一次sync.Once 提供了一种方法, 让相关代码只被执行一次实际开发过程中, 经常有这样的场景: 你做了一个叫做lowLevelApi的包, 用于控制底层设备, 比如开关LED,  但在调用开关LED之前需要确保一些初始化工作已经完成, 所以你写了一个InitEnv的函数, 并告诉其它开发人员: 一定要先初始化哦.package lowLevelApiimport \"fmt\"func InitEnv() {\tfmt.Println(\"init environment\")}func LedOn() {\tfmt.Println(\"LedOn\")}func LedOff() {\tfmt.Println(\"LedOff\")}其它开发人员经常会问你: 这个初始化函数如果被重复调用不会出问题吧?因为他们的代码通常会这样写:package mainimport (\t\"fmt\"\t\"goplayground/lowLevelApi\")func turnLedOn() {\tfmt.Println(\"Turning LED on\")\tlowLevelApi.InitEnv()\tlowLevelApi.LedOn()\tfmt.Println(\"LED on\")}func turnLedOff() {\tfmt.Println(\"Turning LED off\")\tlowLevelApi.InitEnv()\tlowLevelApi.LedOff()\tfmt.Println(\"LED off\")}func main() {\tturnLedOn()\tturnLedOff()}上面的代码会输出Turning LED onInitEnvLedOnLED onTurning LED offInitEnvLedOffLED off为了防止重复调用InitEnv()可能带来的问题, 则可以使用sync.Oncevar (\tonce sync.Once)func InitEnv() {\tonce.Do(func() {\t\tfmt.Println(\"InitEnv\")\t})}这样InitEnv()即使被多次调用, 其内部逻辑只会执行一次Turning LED onInitEnvLedOnLED onTurning LED offLedOffLED offsync.Once 常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。  init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。  sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。sync.Cond 条件变量sync.Cond 用于协调多个协程访问共享资源, 其中某些协程处于阻塞状态, 另外一个协程在条件准备好的时候来讲其它协程唤醒.下面的例子中 InitEnv函数需要一点时间在准备sharedCounter 的初始值, 在这期间Add和sub处于Wait状态,  当准备好后, 将通知 Add和Sub继续向下执行package mainimport (\t\"fmt\"\t\"sync\"\t\"time\")var (\tsharedCounter int)func InitEnv(c *sync.Cond) {\tfmt.Println(\"begin InitEnv\")\ttime.Sleep(time.Second * 1)\tc.L.Lock()\tsharedCounter = 10\tc.L.Unlock()\tfmt.Println(\"Init Env Done, broadcast...\")\tc.Broadcast()}func Add(cout int, c *sync.Cond) {\tc.L.Lock()\tc.Wait()\tsharedCounter += cout\tc.L.Unlock()\tfmt.Println(\"Add Done\")}func Sub(count int, c *sync.Cond) {\tc.L.Lock()\tc.Wait()\tsharedCounter -= count\tc.L.Unlock()\tfmt.Println(\"Sub Done\")}func main() {\tcond := sync.NewCond(&amp;sync.Mutex{})\tgo InitEnv(cond)\tgo Add(5, cond)\tgo Sub(2, cond)\ttime.Sleep(2 * time.Second)\tfmt.Println(\"Final Counter:\", sharedCounter)}输出begin InitEnvInit Env Done, broadcast...Add DoneSub DoneFinal Counter: 13c.Broadcast()唤醒所有等待的协程,   另外还有一个Signal()方法, 用于唤醒一个协程.  sync.Cond一般用于一对多的情况, 如果是一对一的情况, 用一个信道就可以轻松解决了sync.Map内置的map不是并发安全的, 所以 sync.Map 提供了一个功能与map类似但是并发安全的版本可以参考这篇文章  https://juejin.cn/post/6844903895227957262"
  }
  
]

