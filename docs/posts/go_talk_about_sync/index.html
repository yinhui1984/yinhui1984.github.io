<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[Golang]聊聊sync | Zhouyinhui's Space</title><meta name=keywords content="#go#,#golang#,#sync#"><meta name=description content="我们将用些简单的例子来尝试golang中sync包的各种有趣的情况
一个简单的DEMO package main  import &#34;fmt&#34;  var ( 	sharedCounter = 0 )  func add(count int) { 	for i := 0; i < count; i++ { 	sharedCounter++ 	} }  func sub(count int) { 	for i := 0; i < count; i++ { 	sharedCounter-- 	} }  func show() { 	fmt.Println(sharedCounter) }  func main() { 	add(1000000) 	sub(1000000) 	show() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器."><meta name=author content="zhouyinhui"><link rel=canonical href=../../posts/go_talk_about_sync/><link crossorigin=anonymous href=../../assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=../../assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.95.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="[Golang]聊聊sync"><meta property="og:description" content="我们将用些简单的例子来尝试golang中sync包的各种有趣的情况
一个简单的DEMO package main  import &#34;fmt&#34;  var ( 	sharedCounter = 0 )  func add(count int) { 	for i := 0; i < count; i++ { 	sharedCounter++ 	} }  func sub(count int) { 	for i := 0; i < count; i++ { 	sharedCounter-- 	} }  func show() { 	fmt.Println(sharedCounter) }  func main() { 	add(1000000) 	sub(1000000) 	show() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器."><meta property="og:type" content="article"><meta property="og:url" content="/posts/go_talk_about_sync/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-02T09:43:29+08:00"><meta property="article:modified_time" content="2022-06-02T09:43:29+08:00"><meta property="og:site_name" content="zhouyinhui's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[Golang]聊聊sync"><meta name=twitter:description content="我们将用些简单的例子来尝试golang中sync包的各种有趣的情况
一个简单的DEMO package main  import &#34;fmt&#34;  var ( 	sharedCounter = 0 )  func add(count int) { 	for i := 0; i < count; i++ { 	sharedCounter++ 	} }  func sub(count int) { 	for i := 0; i < count; i++ { 	sharedCounter-- 	} }  func show() { 	fmt.Println(sharedCounter) }  func main() { 	add(1000000) 	sub(1000000) 	show() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"[Golang]聊聊sync","item":"/posts/go_talk_about_sync/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Golang]聊聊sync","name":"[Golang]聊聊sync","description":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况\n一个简单的DEMO package main  import \u0026#34;fmt\u0026#34;  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i \u0026lt; count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器.","keywords":["#go#","#golang#","#sync#"],"articleBody":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况\n一个简单的DEMO package main  import \"fmt\"  var ( \tsharedCounter = 0 )  func add(count int) { \tfor i := 0; i count; i++ { \tsharedCounter++ \t} }  func sub(count int) { \tfor i := 0; i count; i++ { \tsharedCounter-- \t} }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tadd(1000000) \tsub(1000000) \tshow() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器. add函数在计数器上循环添加一定的数值, sub则相反, show则是打印计数器当前的值.\n程序运行结束后, sharedCounter应该为0, 上面代码的输出的确如此.\n使用一个协程 如果对计数器进行加减的调用在不同的协程里面, 会怎么样呢?\nfunc main() { \tadd(1000000) \tgo sub(1000000) \tshow() } 会得到1000000 , 因为go sub(1000000)刚启动, 程序就退出了.\n或许我们应该等到sub函数执行结束\n等待协程结束   错误的方式 如果有C语言开发背景, 可能会想到通过设置一个flag来指示运算是否结束, 比如:\nfunc sub(count int, done *bool) { \tfor i := 0; i count; i++ { \tsharedCounter-- \t} \t*done = true } //....  func main() { \tadd(1000000)  \tdone := false \tgo sub(1000000, \u0026done)  \tfor !done { \ttime.Sleep(time.Millisecond * 10) \t}  \tshow() } 这虽然也能得到正确的输出, 但非常不优雅.\n  正确的方式1 可以使用一个无缓冲的信道(或者说容量为1的信道)来充当flag\n//... func sub(count int, done chan bool) { \tfor i := 0; i count; i++ { \tsharedCounter-- \t} \tdone  true } //.... func main() { \tadd(1000000)  \tdone := make(chan bool) \tgo sub(1000000, done) \tsubDone \tshow() } 这里利用了信道的特点: 当从信道中读取数据时,如果信道为空,读取将被阻塞直到有数据到达. 所以  会一直阻塞, 直到通过subDone 向其中写入了数据\n  使用2个协程 上面的例子中, sub(1000000, done)是在新的协程中运行的, add(1000000)却不是, 如果他们都在新协程中运行, 主程序应该如何等待他们结束呢\n很容易想到, 使用两次 也就是说向信道索要两个计算完成的标志, add和 sub 计算完成后分别向其中放入标志.\npackage main  import \"fmt\"  var ( \tsharedCounter = 0 )  func add(count int, done chan bool) { \tfor i := 0; i count; i++ { \tsharedCounter++ \t}  \tfmt.Println(\"add done\") \tdone  true }  func sub(count int, done chan bool) { \tfor i := 0; i count; i++ { \tsharedCounter-- \t} \tfmt.Println(\"sub done\") \tdone  true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \tdone \tdone \tshow() } 为了明确知道main函数的确是等待两个协程执行完毕了的, 我们在其中加入了fmt.Println(\"sub done\")这样的输出\n运行程序, 得到\nadd done sub done 824933 Opps, 虽然add和sub 都执行完毕了,但是结果不对(并且多次运行的结果还不相同), 期望接收应该是0\n再运行一次, 得到:\nsub done add done -481342 原因是add和sub在交叉读取和写入sharedCounter这个变量, 他们共享了变量, 但在读取和写入的时候出现**“竞态”**\n竞态 有多个协程运行时, 对于每个协程而言,其内部代码时顺序执行的, 但无法确定协程之间的执行顺序, 那么就说这些协程是并发的\n如果一段代码无论是顺序执行还是并发执行,其结果都是确定的,那么这个代码就是并发安全的.\n相反, 并发不安全的代码,可能会出现死锁,活锁,竞态\n竞态则表示代码可执行,但可能出现结果不一致(错误结果)\n###解决方法1, 利用信道\nfunc main() { \tdone := make(chan bool) \tgo add(1000000, done) \tdone //1 \tgo sub(1000000, done) \tdone //2 \tshow() } 在add执行完毕之前, 首先会堵塞在//1处,\nfunc add(count int, done chan bool) { \t//.... \tdone  true } add函数执行最后一句 done 后 能取到值, 接触阻塞. 然后继续往下执行sub函数.\n这虽然能得到正确输出, 但, 我们发现, 这实际是将并行执行修改成了串行执行.\n解决方法2, 利用 Mutex 或 RWMutex sync.Mutex 可能是同步包中使用最广泛的原语。它允许对共享资源进行互斥（不能同时访问).\nmutex := \u0026sync.Mutex{}  mutex.Lock() //.... 更新共享变量 mutex.Unlock() 注意: 在官方文档中有这么一句 “Values containing the types defined in this package should not be copied.” (“包含这个包中定义的类型的值不应该被复制。”) . 我们直到值传递就是复制然后传递, 所以我们代码中的mutex用的是引用传递.\npackage main  import ( \t\"fmt\" \t\"sync\" )  var ( \tsharedCounter = 0 \tmutex = \u0026sync.Mutex{} )  func add(count int, done chan bool) { \tfor i := 0; i count; i++ { \tmutex.Lock() \tsharedCounter++ \tmutex.Unlock() \t}  \tfmt.Println(\"add done\") \tdone  true }  func sub(count int, done chan bool) { \tfor i := 0; i count; i++ { \tmutex.Lock() \tsharedCounter-- \tmutex.Unlock() \t} \tfmt.Println(\"sub done\") \tdone  true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \tdone \tdone \tshow() } 在读写sharedCounter之前先Lock(), 用完后Unlock()\n如果我们在进行计算的时候加上点打印(仅测试用,非常影响速度)\nfor i := 0; i count; i++ { \tmutex.Lock() \tfmt.Println(\"--\") // fmt.Println(\"++\") \tsharedCounter-- // sharedCounter++ \tmutex.Unlock() \t} 则可以看到 ++ 和 – 是交叉着打印的, 说明是并行执行的.\n另外, 还有RWMutex (读写锁), 除了与Mutex相同的Lock()和Unlock()方法外, 其还有用于共享读操作的RLock()和RUnlock(), 在读取共享变量时允许同时多个读取器能提高效率. 所以在频繁读写操作的代码中, 使用RWMutex效率要比Mutex高\n解决方法3, 利用原子操作 原子操作在\"sync/atomic\"包中. 利用这个包中提供的函数可实现\"无锁版\"的共享变量读写\n原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作\npackage main  import ( \t\"fmt\" \t\"sync/atomic\" )  var ( \tsharedCounter = int64(0) )  func add(count int, done chan bool) { \tfor i := 0; i count; i++ { \tatomic.AddInt64(\u0026sharedCounter, 1) // \t}  \tfmt.Println(\"add done\") \tdone  true }  func sub(count int, done chan bool) { \tfor i := 0; i count; i++ { \tatomic.AddInt64(\u0026sharedCounter, -1) // \t} \tfmt.Println(\"sub done\") \tdone  true }  func show() { \tfmt.Println(sharedCounter) }  func main() { \tdone := make(chan bool) \tgo add(1000000, done) \tgo sub(1000000, done) \tdone \tdone \tshow() } 原子操作的常用接口如下(以int32为例)\n//将addr指向的值和old进行比较, 如果相等,则将new赋值到addr指向的位置,并返回true, 如果不相等,则直接返回false func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)   //使用原子操作,将addr指向的位置增加一个delta func AddInt32(addr *int32, delta int32) (new int32)  //原子读取 //当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。 func LoadInt32(addr *int32) (val int32)  //读取是有原子性的操作的，同样写入atomic包也提供了相关的操作包 func StoreInt32(addr *int32, val int32)   //此类型的值相当于一个容器，可以被用来“原子地\"存储（Store）和加载（Load）任意类型的值。当然这个类型也是原子性的。 //有了atomic.Value这个类型，这样用户就可以在不依赖Go内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。 // A Value must not be copied after first use. type Value struct { \tv interface{} }  原子操作与互斥锁的区别\n首先atomic操作的优势是更轻量，比如CAS可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。\n原子操作也有劣势。还是以CAS操作为例，使用CAS操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。\n下面是几点区别：\n 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作 原子操作是无锁的，常常直接通过CPU指令直接实现 原子操作中的cas趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理 可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程    不要轻易使用atomic\nhttps://texlution.com/post/golang-lock-free-values-with-atomic-value/\n 其它并发控制方法 上面的例子中, 我们都是使用的信道来进行并发控制 (done 与), 这只是常用的方法之一\nWaitGroup sync.WaitGroup 拥有一个内部计数器。如果此计数器等于 0，则 Wait() 方法立即返回。否则，它将被阻塞，直到计数器为 0。\n要增加计数器，我们必须使用 Add(int)。要减少它，我们可以使用 Done() （将减少 1）或具有负值的相同 Add(int) 方法。\npackage main  import (  \"fmt\"  \"sync\"  \"sync/atomic\" )  var (  sharedCounter = int64(0) )  func add(count int, wg *sync.WaitGroup) {  for i := 0; i count; i++ {  atomic.AddInt64(\u0026sharedCounter, 1)  }   fmt.Println(\"add done\")  wg.Done() }  func sub(count int, wg *sync.WaitGroup) {  for i := 0; i count; i++ {  atomic.AddInt64(\u0026sharedCounter, -1)  }  fmt.Println(\"sub done\")  wg.Done() }  func show() {  fmt.Println(sharedCounter) }  func main() {  wg := sync.WaitGroup{}  wg.Add(2)   go add(1000000, \u0026wg)  go sub(1000000, \u0026wg)   wg.Wait()  show() } 注意:传递 WaitGroup时要使用引用传递(指针), 其不应该被复制. func sub(count int, wg *sync.WaitGroup)\ncontext.Context Context提供了2个功能\n 控制子协程结束 传递值  其不在sync包中, 后面专门讲\nsync.Pool 对象复用 其提供一个\"并发安全\"的可复用的对象池. 用来减少频繁GC所代理的压力.\n其大概意思是: 如果有旧对象可用,则用旧的, 没有再New一个\n参考这批文章: https://www.cnblogs.com/qcrao-2018/p/12736031.html\n以及这里 https://geektutu.com/post/hpg-sync-pool.html\n在实际开发工作中, 不要一上来就想做使用sync.Pool它通常会带来问题(因为其Get出来的对象的状态是不确定的), 而应该遵循下面的原则:\n 根据你收集到的需求设计你的代码（不要跳过这个步骤）。 编写最简单、最清晰、最愚蠢的设计实现。 如果客户满意，就停止 如果客户不满意，而且他们认为应用程序的性能不能满足他们的要求，那么就剖析。 解决最高性能的主导者 剖析并进入第五阶段。然后进入3 如果实在搞不定, 再想想sync.Pool  sync.Once 只执行一次 sync.Once 提供了一种方法, 让相关代码只被执行一次\n实际开发过程中, 经常有这样的场景: 你做了一个叫做lowLevelApi的包, 用于控制底层设备, 比如开关LED, 但在调用开关LED之前需要确保一些初始化工作已经完成, 所以你写了一个InitEnv的函数, 并告诉其它开发人员: 一定要先初始化哦.\npackage lowLevelApi  import \"fmt\"  func InitEnv() { \tfmt.Println(\"init environment\") }  func LedOn() { \tfmt.Println(\"LedOn\") }  func LedOff() { \tfmt.Println(\"LedOff\") } 其它开发人员经常会问你: 这个初始化函数如果被重复调用不会出问题吧?\n因为他们的代码通常会这样写:\npackage main  import ( \t\"fmt\" \t\"goplayground/lowLevelApi\" )  func turnLedOn() { \tfmt.Println(\"Turning LED on\") \tlowLevelApi.InitEnv() \tlowLevelApi.LedOn() \tfmt.Println(\"LED on\") }  func turnLedOff() { \tfmt.Println(\"Turning LED off\") \tlowLevelApi.InitEnv() \tlowLevelApi.LedOff() \tfmt.Println(\"LED off\") }  func main() { \tturnLedOn() \tturnLedOff() } 上面的代码会输出\nTurning LED on InitEnv LedOn LED on Turning LED off InitEnv LedOff LED off 为了防止重复调用InitEnv()可能带来的问题, 则可以使用sync.Once\nvar ( \tonce sync.Once )  func InitEnv() { \tonce.Do(func() { \tfmt.Println(\"InitEnv\") \t}) } 这样InitEnv()即使被多次调用, 其内部逻辑只会执行一次\nTurning LED on InitEnv LedOn LED on Turning LED off LedOff LED off sync.Once 常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。\n init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。 sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。  sync.Cond 条件变量 sync.Cond 用于协调多个协程访问共享资源, 其中某些协程处于阻塞状态, 另外一个协程在条件准备好的时候来讲其它协程唤醒.\n下面的例子中 InitEnv函数需要一点时间在准备sharedCounter 的初始值, 在这期间Add和sub处于Wait状态, 当准备好后, 将通知 Add和Sub继续向下执行\npackage main  import ( \t\"fmt\" \t\"sync\" \t\"time\" )  var ( \tsharedCounter int )  func InitEnv(c *sync.Cond) { \tfmt.Println(\"begin InitEnv\") \ttime.Sleep(time.Second * 1) \tc.L.Lock() \tsharedCounter = 10 \tc.L.Unlock() \tfmt.Println(\"Init Env Done, broadcast...\") \tc.Broadcast() }  func Add(cout int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter += cout \tc.L.Unlock() \tfmt.Println(\"Add Done\") }  func Sub(count int, c *sync.Cond) { \tc.L.Lock() \tc.Wait() \tsharedCounter -= count \tc.L.Unlock() \tfmt.Println(\"Sub Done\") }  func main() { \tcond := sync.NewCond(\u0026sync.Mutex{}) \tgo InitEnv(cond) \tgo Add(5, cond) \tgo Sub(2, cond)  \ttime.Sleep(2 * time.Second) \tfmt.Println(\"Final Counter:\", sharedCounter) } 输出\nbegin InitEnv Init Env Done, broadcast... Add Done Sub Done Final Counter: 13 c.Broadcast()唤醒所有等待的协程, 另外还有一个Signal()方法, 用于唤醒一个协程. sync.Cond一般用于一对多的情况, 如果是一对一的情况, 用一个信道就可以轻松解决了\nsync.Map 内置的map不是并发安全的, 所以 sync.Map 提供了一个功能与map类似但是并发安全的版本\n可以参考这篇文章 https://juejin.cn/post/6844903895227957262\n","wordCount":"1051","inLanguage":"en","datePublished":"2022-06-02T09:43:29+08:00","dateModified":"2022-06-02T09:43:29+08:00","author":{"@type":"Person","name":"zhouyinhui"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/go_talk_about_sync/"},"publisher":{"@type":"Organization","name":"Zhouyinhui's Space","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Zhouyinhui's Space (Alt + H)">Zhouyinhui's Space</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=../../ title=home><span>home</span></a></li><li><a href=../../tags/ title=tags><span>tags</span></a></li><li><a href=../../archives/ title=archives><span>archives</span></a></li><li><a href=../../search/ title="🔍search (Alt + /)" accesskey=/><span>🔍search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=../../posts/>Posts</a></div><h1 class=post-title>[Golang]聊聊sync</h1><div class=post-meta><span title="2022-06-02 09:43:29 +0800 CST">June 2, 2022</span>&nbsp;·&nbsp;zhouyinhui</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84demo aria-label=一个简单的DEMO>一个简单的DEMO</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e4%b8%80%e4%b8%aa%e5%8d%8f%e7%a8%8b aria-label=使用一个协程>使用一个协程</a><ul><li><a href=#%e7%ad%89%e5%be%85%e5%8d%8f%e7%a8%8b%e7%bb%93%e6%9d%9f aria-label=等待协程结束>等待协程结束</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a82%e4%b8%aa%e5%8d%8f%e7%a8%8b aria-label=使用2个协程>使用2个协程</a><ul><li><a href=#%e7%ab%9e%e6%80%81 aria-label=竞态>竞态</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%952-%e5%88%a9%e7%94%a8-mutex-%e6%88%96-rwmutex aria-label="解决方法2, 利用 Mutex 或 RWMutex">解决方法2, 利用 Mutex 或 RWMutex</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%953-%e5%88%a9%e7%94%a8%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c aria-label="解决方法3, 利用原子操作">解决方法3, 利用原子操作</a></li></ul></li><li><a href=#%e5%85%b6%e5%ae%83%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e6%96%b9%e6%b3%95 aria-label=其它并发控制方法>其它并发控制方法</a><ul><li><a href=#waitgroup aria-label=WaitGroup>WaitGroup</a></li><li><a href=#contextcontext aria-label=context.Context>context.Context</a></li></ul></li><li><a href=#syncpool-%e5%af%b9%e8%b1%a1%e5%a4%8d%e7%94%a8 aria-label="sync.Pool 对象复用">sync.Pool 对象复用</a></li><li><a href=#synconce-%e5%8f%aa%e6%89%a7%e8%a1%8c%e4%b8%80%e6%ac%a1 aria-label="sync.Once 只执行一次">sync.Once 只执行一次</a></li><li><a href=#synccond-%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f aria-label="sync.Cond 条件变量">sync.Cond 条件变量</a></li><li><a href=#syncmap aria-label=sync.Map>sync.Map</a></li></ul></div></details></div><div class=post-content><p>我们将用些简单的例子来尝试golang中sync包的各种有趣的情况</p><h2 id=一个简单的demo>一个简单的DEMO<a hidden class=anchor aria-hidden=true href=#一个简单的demo>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>show</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sharedCounter</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>程序很简单, 我们用一个共享变量<code>sharedCounter</code>作为一个计数器. <code>add</code>函数在计数器上循环添加一定的数值, sub则相反, show则是打印计数器当前的值.</p><p>程序运行结束后, <code>sharedCounter</code>应该为0, 上面代码的输出的确如此.</p><h2 id=使用一个协程>使用一个协程<a hidden class=anchor aria-hidden=true href=#使用一个协程>#</a></h2><p>如果对计数器进行加减的调用在不同的协程里面, 会怎么样呢?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>会得到<code>1000000</code> , 因为<code>go sub(1000000)</code>刚启动, 程序就退出了.</p><p>或许我们应该等到<code>sub</code>函数执行结束</p><h3 id=等待协程结束>等待协程结束<a hidden class=anchor aria-hidden=true href=#等待协程结束>#</a></h3><ul><li><p>错误的方式
如果有C语言开发背景, 可能会想到通过设置一个flag来指示运算是否结束, 比如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>done</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>done</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这虽然也能得到正确的输出, 但非常不优雅.</p></li><li><p>正确的方式1
可以使用一个无缓冲的信道(或者说容量为1的信道)来充当flag</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>subDone</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里利用了信道的特点: <strong>当从信道中读取数据时,如果信道为空,读取将被阻塞直到有数据到达</strong>. 所以 <code>&lt;-subDone</code> 会一直阻塞, 直到通过<code>subDone &lt;- true</code>向其中写入了数据</p></li></ul><h2 id=使用2个协程>使用2个协程<a hidden class=anchor aria-hidden=true href=#使用2个协程>#</a></h2><p>上面的例子中, <code>sub(1000000, done)</code>是在新的协程中运行的, <code>add(1000000)</code>却不是, 如果他们都在新协程中运行, 主程序应该如何等待他们结束呢</p><p>很容易想到, 使用两次<code>&lt;-done</code> 也就是说向信道索要两个计算完成的标志, <code>add</code>和 <code>sub</code> 计算完成后分别向其中放入标志.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;add done&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;sub done&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>show</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sharedCounter</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了明确知道main函数的确是等待两个协程执行完毕了的, 我们在其中加入了<code>fmt.Println("sub done")</code>这样的输出</p><p>运行程序, 得到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>add <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>sub <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>824933</span>
</span></span></code></pre></div><p><strong>Opps, 虽然<code>add</code>和<code>sub</code> 都执行完毕了,但是结果不对(并且多次运行的结果还不相同), 期望接收应该是<code>0</code></strong></p><p>再运行一次, 得到:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sub <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>add <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>-481342
</span></span></code></pre></div><p>原因是<code>add</code>和<code>sub</code>在交叉读取和写入<code>sharedCounter</code>这个变量, 他们共享了变量, 但在读取和写入的时候出现**&ldquo;竞态&rdquo;**</p><h3 id=竞态>竞态<a hidden class=anchor aria-hidden=true href=#竞态>#</a></h3><p>有多个协程运行时, 对于每个协程而言,其内部代码时顺序执行的, 但无法确定协程之间的执行顺序, 那么就说这些协程是并发的</p><p>如果一段代码无论是顺序执行还是并发执行,其结果都是确定的,那么这个代码就是并发安全的.</p><p>相反, 并发不安全的代码,可能会出现死锁,活锁,竞态</p><p>竞态则表示代码可执行,但可能出现结果不一致(错误结果)</p><p>###解决方法1, 利用信道</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span> <span style=color:#75715e>//1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span> <span style=color:#75715e>//2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>add</code>执行完毕之前, 首先会堵塞在<code>//1</code>处,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//....
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>add</code>函数执行最后一句 <code>done &lt;- true</code> 后 <code>&lt;-done //1</code>能取到值, 接触阻塞. 然后继续往下执行<code>sub</code>函数.</p><p>这虽然能得到正确输出, 但, 我们发现, <strong>这实际是将并行执行修改成了串行执行.</strong></p><h3 id=解决方法2-利用-mutex-或-rwmutex>解决方法2, 利用 Mutex 或 RWMutex<a hidden class=anchor aria-hidden=true href=#解决方法2-利用-mutex-或-rwmutex>#</a></h3><p>sync.Mutex 可能是同步包中使用最广泛的原语。它允许对共享资源进行互斥（不能同时访问).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>mutex</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#75715e>//.... 更新共享变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span></code></pre></div><p>注意: 在官方文档中有这么一句 &ldquo;Values containing the types defined in this package should not be copied.&rdquo; (&ldquo;包含这个包中定义的类型的值不应该被复制。&rdquo;) . 我们直到值传递就是复制然后传递, 所以我们代码中的mutex用的是引用传递.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mutex</span>         = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>{}
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;add done&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;sub done&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>show</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sharedCounter</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在读写<code>sharedCounter</code>之前先<code>Lock()</code>, 用完后<code>Unlock()</code></p><p>如果我们在进行计算的时候加上点打印(仅测试用,非常影响速度)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;--&#34;</span>) <span style=color:#75715e>// fmt.Println(&#34;++&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>sharedCounter</span><span style=color:#f92672>--</span>   <span style=color:#75715e>// sharedCounter++
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>mutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>则可以看到 ++ 和 &ndash; 是交叉着打印的, 说明是并行执行的.</p><p>另外, 还有<code>RWMutex</code> (读写锁), 除了与<code>Mutex</code>相同的<code>Lock()</code>和<code>Unlock()</code>方法外, 其还有用于共享读操作的<code>RLock()</code>和<code>RUnlock()</code>, 在读取共享变量时允许同时多个读取器能提高效率. 所以在频繁读写操作的代码中, 使用<code>RWMutex</code>效率要比<code>Mutex</code>高</p><h3 id=解决方法3-利用原子操作>解决方法3, 利用原子操作<a hidden class=anchor aria-hidden=true href=#解决方法3-利用原子操作>#</a></h3><p>原子操作在<code>"sync/atomic"</code>包中. 利用这个包中提供的函数可实现"无锁版"的共享变量读写</p><p><code>原子操作</code>即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。<strong>原子操作是无锁的，常常直接通过CPU指令直接实现。</strong> 事实上，其它同步技术的实现常常依赖于原子操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync/atomic&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> = int64(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sharedCounter</span>, <span style=color:#ae81ff>1</span>) <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;add done&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sharedCounter</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;sub done&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>show</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sharedCounter</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>原子操作的常用接口如下(以<code>int32</code>为例)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//将addr指向的值和old进行比较, 如果相等,则将new赋值到addr指向的位置,并返回true, 如果不相等,则直接返回false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int32</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//使用原子操作,将addr指向的位置增加一个delta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>int32</span>) (<span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int32</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//原子读取
</span></span></span><span style=display:flex><span><span style=color:#75715e>//当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>) (<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int32</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//读取是有原子性的操作的，同样写入atomic包也提供了相关的操作包
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StoreInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int32</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//此类型的值相当于一个容器，可以被用来“原子地&#34;存储（Store）和加载（Load）任意类型的值。当然这个类型也是原子性的。
</span></span></span><span style=display:flex><span><span style=color:#75715e>//有了atomic.Value这个类型，这样用户就可以在不依赖Go内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A Value must not be copied after first use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Value</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>原子操作与互斥锁的区别</p><p>首先atomic操作的优势是更轻量，比如CAS可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。</p><p>原子操作也有劣势。还是以CAS操作为例，使用CAS操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。</p><p>下面是几点区别：</p><ul><li>互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作</li><li>原子操作是无锁的，常常直接通过CPU指令直接实现</li><li>原子操作中的cas趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理</li><li>可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</li></ul></blockquote><blockquote><p>不要轻易使用atomic</p><p><a href=https://texlution.com/post/golang-lock-free-values-with-atomic-value/>https://texlution.com/post/golang-lock-free-values-with-atomic-value/</a></p></blockquote><h2 id=其它并发控制方法>其它并发控制方法<a hidden class=anchor aria-hidden=true href=#其它并发控制方法>#</a></h2><p>上面的例子中, 我们都是使用的信道来进行并发控制 (<code>done &lt;- true</code>与<code>&lt;-done</code>), 这只是常用的方法之一</p><h3 id=waitgroup>WaitGroup<a hidden class=anchor aria-hidden=true href=#waitgroup>#</a></h3><p><code>sync.WaitGroup </code>拥有一个内部计数器。如果此计数器等于 0，则 <code>Wait()</code> 方法立即返回。否则，它将被阻塞，直到计数器为 0。</p><p>要增加计数器，我们必须使用<code> Add(int)</code>。要减少它，我们可以使用 <code>Done()</code> （将减少 1）或具有负值的相同 <code>Add(int)</code> 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;sync/atomic&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>sharedCounter</span> = int64(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sharedCounter</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;add done&#34;</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>count</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>AddInt64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sharedCounter</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;sub done&#34;</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>show</span>() {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sharedCounter</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>)
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>1000000</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>show</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意:传递 <code>WaitGroup</code>时要使用引用传递(指针), 其不应该被复制. <code>func sub(count int, wg *sync.WaitGroup)</code></p><h3 id=contextcontext>context.Context<a hidden class=anchor aria-hidden=true href=#contextcontext>#</a></h3><p><code>Context</code>提供了2个功能</p><ol><li>控制子协程结束</li><li>传递值</li></ol><p>其不在<code>sync</code>包中, 后面专门讲</p><h2 id=syncpool-对象复用>sync.Pool 对象复用<a hidden class=anchor aria-hidden=true href=#syncpool-对象复用>#</a></h2><p>其提供一个"并发安全"的可复用的对象池. 用来减少频繁GC所代理的压力.</p><p>其大概意思是: 如果有旧对象可用,则用旧的, 没有再New一个</p><p>参考这批文章: <a href=https://www.cnblogs.com/qcrao-2018/p/12736031.html>https://www.cnblogs.com/qcrao-2018/p/12736031.html</a></p><p>以及这里 <a href=https://geektutu.com/post/hpg-sync-pool.html>https://geektutu.com/post/hpg-sync-pool.html</a></p><p>在实际开发工作中, 不要一上来就想做使用<code>sync.Pool</code>它通常会带来问题(因为其<code>Get</code>出来的对象的状态是不确定的), 而应该遵循下面的原则:</p><ol><li>根据你收集到的需求设计你的代码（不要跳过这个步骤）。</li><li>编写最简单、最清晰、最愚蠢的设计实现。</li><li>如果客户满意，就停止</li><li>如果客户不满意，而且他们认为应用程序的性能不能满足他们的要求，那么就剖析。</li><li>解决最高性能的主导者</li><li>剖析并进入第五阶段。然后进入3</li><li>如果实在搞不定, 再想想<code>sync.Pool</code></li></ol><h2 id=synconce-只执行一次>sync.Once 只执行一次<a hidden class=anchor aria-hidden=true href=#synconce-只执行一次>#</a></h2><p>sync.Once 提供了一种方法, 让相关代码只被执行一次</p><p>实际开发过程中, 经常有这样的场景: 你做了一个叫做<code>lowLevelApi</code>的包, 用于控制底层设备, 比如开关LED, 但在调用开关LED之前需要确保一些初始化工作已经完成, 所以你写了一个<code>InitEnv</code>的函数, 并告诉其它开发人员: 一定要先初始化哦.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>lowLevelApi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitEnv</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;init environment&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LedOn</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;LedOn&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LedOff</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;LedOff&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其它开发人员经常会问你: 这个初始化函数如果被重复调用不会出问题吧?</p><p>因为他们的代码通常会这样写:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;goplayground/lowLevelApi&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>turnLedOn</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Turning LED on&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lowLevelApi</span>.<span style=color:#a6e22e>InitEnv</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lowLevelApi</span>.<span style=color:#a6e22e>LedOn</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;LED on&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>turnLedOff</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Turning LED off&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lowLevelApi</span>.<span style=color:#a6e22e>InitEnv</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lowLevelApi</span>.<span style=color:#a6e22e>LedOff</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;LED off&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>turnLedOn</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>turnLedOff</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的代码会输出</p><pre tabindex=0><code>Turning LED on
InitEnv
LedOn
LED on
Turning LED off
InitEnv
LedOff
LED off
</code></pre><p>为了防止重复调用<code>InitEnv()</code>可能带来的问题, 则可以使用<code>sync.Once</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>once</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Once</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitEnv</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>once</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;InitEnv&#34;</span>)
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样<code>InitEnv()</code>即使被多次调用, 其内部逻辑只会执行一次</p><pre tabindex=0><code>Turning LED on
InitEnv
LedOn
LED on
Turning LED off
LedOff
LED off
</code></pre><p><code>sync.Once</code> 常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 <code>init</code> 函数类似，但有区别。</p><ul><li>init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。</li><li>sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。</li></ul><h2 id=synccond-条件变量>sync.Cond 条件变量<a hidden class=anchor aria-hidden=true href=#synccond-条件变量>#</a></h2><p><code>sync.Cond</code> 用于协调多个协程访问共享资源, 其中某些协程处于阻塞状态, 另外一个协程在条件准备好的时候来讲其它协程唤醒.</p><p>下面的例子中 <code>InitEnv</code>函数需要一点时间在准备<code>sharedCounter</code> 的初始值, 在这期间<code>Add</code>和<code>sub</code>处于<code>Wait</code>状态, 当准备好后, 将通知 <code>Add</code>和<code>Sub</code>继续向下执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitEnv</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Cond</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;begin InitEnv&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Init Env Done, broadcast...&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Broadcast</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>cout</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Cond</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>cout</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Add Done&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Cond</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sharedCounter</span> <span style=color:#f92672>-=</span> <span style=color:#a6e22e>count</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Sub Done&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cond</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>NewCond</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>{})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>InitEnv</span>(<span style=color:#a6e22e>cond</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>cond</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>Sub</span>(<span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>cond</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Final Counter:&#34;</span>, <span style=color:#a6e22e>sharedCounter</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出</p><pre tabindex=0><code>begin InitEnv
Init Env Done, broadcast...
Add Done
Sub Done
Final Counter: 13
</code></pre><p><code>c.Broadcast()</code>唤醒所有等待的协程, 另外还有一个<code>Signal()</code>方法, 用于唤醒一个协程. <code>sync.Cond</code>一般用于一对多的情况, 如果是一对一的情况, 用一个信道就可以轻松解决了</p><h2 id=syncmap>sync.Map<a hidden class=anchor aria-hidden=true href=#syncmap>#</a></h2><p>内置的<code>map</code>不是并发安全的, 所以 <code>sync.Map</code> 提供了一个功能与<code>map</code>类似但是并发安全的版本</p><p>可以参考这篇文章 <a href=https://juejin.cn/post/6844903895227957262>https://juejin.cn/post/6844903895227957262</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=../../tags/#go%23/>#go#</a></li><li><a href=../../tags/#golang%23/>#golang#</a></li><li><a href=../../tags/#sync%23/>#sync#</a></li></ul><nav class=paginav><a class=prev href=../../posts/golang_http_server/><span class=title>« Prev Page</span><br><span>[Golang]Http Server</span></a>
<a class=next href=../../posts/golang_overseer_restart_app/><span class=title>Next Page »</span><br><span>[Golang] 使用overseer实现APP重启</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href>Zhouyinhui's Space</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>