[{"categories":["BlockChain"],"content":"前面在 从零开始编写智能合约-使用traffle套件 中 使用 truffle套件从零开始搭建环境, 编写、部署、测试和调用智能合约, 这次我们只使用一些命令行工具来进行\"手工打造\" 配套代码: https://github.com/yinhui1984/stepByStepSmartContract ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:0:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"创建测试链 还是以ETH为例, 使用 Go Ethereum https://geth.ethereum.org 来创建 使用POW共识算法的一个简单私有链. ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"安装geth 官方教程 https://geth.ethereum.org/docs/install-and-build/installing-geth 或者自己下载安装包进行安装 https://geth.ethereum.org/downloads/ 安装完成后, 运行一下version表示成功 OSX MP16 ~/Downloads/privateNetwork ❯ geth version Geth Version: 1.10.16-stable Architecture: amd64 Go Version: go1.17.6 Operating System: darwin GOPATH= GOROOT=go ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:1","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"创建一个账户 下面的创世文件中的coinbase会用到这个账户, 用来接收挖矿的收入 为方便起见, 将账户密码写到password.txt , 当然这是不安全的行为. echo 123456 \u003e password.txt 新建账户: geth --datadir ./data/ account new --password ./password.txt 其中的datadir是数据存储目录, 后面的数据文件都将存到这个目录中 OSX MP16 ~/Downloads/privateNetwork ❯ geth --datadir ./data/ account new --password ./password.txt INFO [07-01|10:10:34.007] Maximum peer count ETH=50 LES=0 total=50 Your new key was generated Public address of the key: 0x79dF0D3c23f22370881dC92aF524A1D5E52e3552 Path of the secret key file: data/keystore/UTC--2022-07-01T02-10-34.008109000Z--79df0d3c23f22370881dc92af524a1d5e52e3552 - You can share your public address with anyone. Others need it to interact with you. - You must NEVER share the secret key with anyone! The key controls access to your funds! - You must BACKUP your key file! Without the key, it's impossible to access account funds! - You must REMEMBER your password! Without the password, it's impossible to decrypt the key! 打印内容中的 0x79dF0D3c23f22370881dC92aF524A1D5E52e3552是公钥, 也是我们的账户地址 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:2","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"找一个网络ID chainId或者network ID 用于隔离以太坊对等网络。只有当两个对等点使用相同的创世块和网络 ID 时，区块链节点之间才会发生连接。使用 –networkid 命令行选项设置 geth 使用的网络 ID。 以太网主网 ID 为 1。如果您提供与主网不同的自定义网络 ID，您的节点将不会连接到其他节点并形成专用网络。如果您打算在 Internet 上连接到您的私有链，最好选择一个尚未使用的网络 ID。您可以在 https://chainid.network 找到由社区运行的以太坊网络注册表。 这里我们只是在本地运行, 随便使用一个ID就可以了, 比如1235 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:3","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"编写\"创世文件\" 一个新的区块链在生成第一个区块, 也就是创世块的时候, 需要从创世文件来进行生成 touch genesis.json { \"nonce\": \"0x0000000000000042\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x00\", \"gasLimit\": \"0x8000000\", \"difficulty\": \"0x0400\", \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x79dF0D3c23f22370881dC92aF524A1D5E52e3552\", \"alloc\": { \"0x79dF0D3c23f22370881dC92aF524A1D5E52e3552\": { \"balance\": \"1000000000000000000000\" } }, \"config\": { \"chainId\": 1235, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip155Block\": 0, \"eip158Block\": 0 } } 关于创世文件中的各个字段的含义, 后面会有一篇专门的博客来讲 注意: 将coinbase 以及 alloc中的地址修改为上面创建账户时你所得到的地址 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:4","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"初始化区块链 geth --datadir ./data init ./genesis.json 输出 INFO [07-01|10:50:50.915] Maximum peer count ETH=50 LES=0 total=50 INFO [07-01|10:50:50.919] Set global gas cap cap=50,000,000 INFO [07-01|10:50:50.919] Allocated cache and file handles database=/Users/zhouyinhui/Downloads/privateNetwork/data/geth/chaindata cache=16.00MiB handles=16 INFO [07-01|10:50:51.007] Writing custom genesis block INFO [07-01|10:50:51.010] Persisted trie from memory database nodes=0 size=0.00B time=\"21.005µs\" gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [07-01|10:50:51.011] Successfully wrote genesis state database=chaindata hash=0ca0fb..b61b69 INFO [07-01|10:50:51.011] Allocated cache and file handles database=/Users/zhouyinhui/Downloads/privateNetwork/data/geth/lightchaindata cache=16.00MiB handles=16 INFO [07-01|10:50:51.090] Writing custom genesis block INFO [07-01|10:50:51.090] Persisted trie from memory database nodes=0 size=0.00B time=\"2.71µs\" gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [07-01|10:50:51.091] Successfully wrote genesis state database=lightchaindata hash=0ca0fb..b61b69 OSX MP16 ~/Downloads/privateNetwork ❯ 生成的文件在 ./data/geth下 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:5","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"运行区块链 geth --datadir ./data/ --networkid 1235 --port 8545 --http --http.api 'admin,eth,miner,net,txpool,personal,web3' --mine --allow-insecure-unlock --unlock '0x79dF0D3c23f22370881dC92aF524A1D5E52e3552' --password password.txt --datadir 数据文件目录 --networkid 网络ID --port RPC端口 --http 启用http-rpc服务 --http.api提供那些API --mine 启用挖矿 --allow-insecure-unlock 当账户相关的RPC被http暴露时，允许不安全的账户解锁 --unlock 解锁账户 (多个账户用逗号分割) --password 解锁账户用到的密码文件 成功运行后, 会看到很多打印信息, 其中值得注意的是下面这两行, 一个是ipc, 一个是http server, 我们会使用他们来和我们的区块链进行通讯 INFO [07-01|11:08:58.245] IPC endpoint opened url=/Users/zhouyinhui/Downloads/privateNetwork/data/geth.ipc INFO [07-01|11:08:58.245] HTTP server started endpoint=127.0.0.1:8545 prefix= cors= vhosts=localhost 另外一条是 我们作为区块链中的对等节点PEER NODE时的信息, 这里我们还用不到 Started P2P networking self=enode://de2537c5f309be45bcb2d011cd172138db40295f74a288b07e03635e2194e7c2987cf97c9d295dc502053d9f7adda11052597c7f1bc5a5ec3d8182777138a0f1@127.0.0.1:8545 请保持区块链在后台运行, 后面的代码都需要用到 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:2:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"与测试链进行交互 attach到测试链, 就可以启动一个js console, 和truffle console功能一样 方式1, 通过IPC进行attach geth attach /Users/zhouyinhui/Downloads/privateNetwork/data/geth.ipc OSX MP16 ~/blockchain/private_net/tempchain ❯ geth attach /Users/zhouyinhui/Downloads/privateNetwork/data/geth.ipc Welcome to the Geth JavaScript console! .... To exit, press ctrl-d or type exit \u003e eth.chainId() \"0x4d3\" \u003e \"0x4d3\" 也就是 我们的 1235 其中 *.ipc 可以使用相对路径 方式2, 通过http服务进行attach geth attach http://127.0.0.1:8545 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:3:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"一键生成测试链 上面那些繁琐的步骤可以搞成一个脚本, 一键生成, 这样来得更方便 #!/usr/bin/env python3 # 一键创建ETH私有链，共识算法POW，如果要使用POA请修改createGenesisFile()中的配置文件 # 这只是练习使用，更好的做法是使用 ganache-cli import os import subprocess import re from typing import List ROOT_FOLDER = os.getcwd() DATA_FOLDER = \"./data/\" ACCOUNT_FILE = \"accounts.txt\" PASSWORD_FILE = \"password.txt\" GENESIS_FILE = \"genesis.json\" CHAIN_ID = \"\" def run_command(cmd: List): sp = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) out, err = sp.communicate() out = out.decode('utf-8').rstrip() err = err.decode('utf-8').rstrip() rtn = sp.returncode if out: # print(\"[output]\"+out) return out if err: print(\"return code:\" + str(rtn) + \" : \" + err) return err def ask_root_folder(): i = input(\"the folder path of output:\") p = os.path.abspath(i) if not os.path.exists(p): os.mkdir(p) global ROOT_FOLDER ROOT_FOLDER = p print(ROOT_FOLDER) os.chdir(ROOT_FOLDER) def create_account(): # geth account new --password \u003c(echo $mypassword) account = \"\" password = input(\"password of new account:\") with open(PASSWORD_FILE, \"w+\") as f: f.write(password) out = run_command([\"geth\", \"--datadir\", DATA_FOLDER, \"account\", \"new\", \"--password\", \"./password.txt\"]) m = re.search('0x.+', out) if m: account = m.group(0) with open(ACCOUNT_FILE, \"w+\") as f: f.write(account) print(\"account: \" + account + \" with password:\" + password) else: print(\"creat account error!\") quit() return account def create_genesis(coinbase): # use os.system(\"puppeth\") is another option global CHAIN_ID CHAIN_ID = input(\"id of chain (numbers):\") g = ''' {{ \"nonce\": \"0x0000000000000042\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x00\", \"gasLimit\": \"0x8000000\", \"difficulty\": \"0x0400\", \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"{}\", \"alloc\": {{ }}, \"config\": {{ \"chainId\": {}, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }} }} '''.format(coinbase, CHAIN_ID) print(g) with open(GENESIS_FILE, \"w+\") as f: f.write(g) def init_chain(): run_command([\"geth\", \"--datadir\", DATA_FOLDER, \"init\", GENESIS_FILE]) def create_run_script(account): # do not add --http.corsdomain '*' , it's not safe for private chain cmd = ''' geth --datadir {}--networkid {}--port 30310 --http --http.api 'admin,eth,miner,net,txpool,personal,web3' --mine --allow-insecure-unlock --unlock '{}' --password password.txt '''.format(DATA_FOLDER, CHAIN_ID, account) with open(\"run.sh\", \"w+\") as f: f.write(cmd) run_command([\"chmod\", \"+x\", \"run.sh\"]) # runCommand([\"sh\", \"run.sh\"]) def create_attach_script(): cmd = ''' geth attach {}geth.ipc '''.format(DATA_FOLDER) with open(\"attach.sh\", \"w+\") as f: f.write(cmd) run_command([\"chmod\", \"+x\", \"attach.sh\"]) def main(): ask_root_folder() account = create_account() create_genesis(account) init_chain() create_run_script(account) create_attach_script() print(\"DONE\") if __name__ == \"__main__\": main() ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:4:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"编写智能合约 我们还是使用 上篇博客中的智能合约 mkdir ./contracts cd ./contracts touch Calculator.sol // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Calculator { function add(int a, int b) public pure returns (int) { return a + b; } function subtract(int a, int b) public pure returns (int) { return a - b; } } ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:5:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"编译智能合约 如果你的电脑上没有solc, 请事先安装, 它是solidity的编译器, 官方教程: https://docs.soliditylang.org/en/v0.8.15/installing-solidity.html#installing-solidity 编译: solc --bin --abi -o ./build ./Calculator.sol --bin 生成16进制文件 --abi生成abi文件 -o输出目录 可以写一个Makefile来干这个事情: all: solc --bin --abi --overwrite -o ./build ./Calculator.sol clean: rm -rf ./build/* OSX MP16 ~/Downloads/privateNetwork/contracts ❯ tree . ├── Calculator.sol ├── Makefile └── build ├── Calculator.abi └── Calculator.bin ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:6:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"部署智能合约 新建一个node.js 项目deploy mkdir -p deploy/ cd deploy/ npm init touch index.js 安装web3.js npm install web3 在index.js中加入如下代码: const fs = require('fs'); const Web3 = require('web3'); const web3 = new Web3('http://127.0.0.1:8545'); const bytecode = fs.readFileSync('../build/Calculator.bin').toString(); const abi = JSON.parse(fs.readFileSync('../build/Calculator.abi').toString()); (async function () { const ganacheAccounts = await web3.eth.getAccounts(); const calculator = new web3.eth.Contract(abi); calculator.deploy({ data: bytecode }).send({ from: ganacheAccounts[0], }).then((deployment) =\u003e { console.log('Contract was deployed at the following address:'); console.log(deployment.options.address); }).catch((err) =\u003e { console.error(err); }); })(); 注意, 上面的部署代码没有使用账户的私钥, 是因为在前面的步骤中, 账户已经解锁了 在部署之前需要先启动挖矿 OSX MP16 ~/Downloads/pri/mychain ❯ ./attach.sh ... \u003e miner.start() null \u003e eth.blockNumber 26 部署: OSX MP16 ~/Downloads/pri/c/d/deploy_js ❯ node ./index.js Contract was deployed at the following address: 0x1F55d61D5Aa8eC92FD1Da0f19FaC9D552A29DBBF 部署成功, 停掉挖矿, 否则电脑巨烫… \u003e miner.stop() null ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:7:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"调用智能合约 调用智能合约就和 从零开始编写智能合约-使用traffle套件中的一样了, 可以跳转到那里进行参考 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:8:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"这篇文章将带你使用traffle套件从零开始搭建环境, 编写、部署、测试和调用智能合约。 配套代码在 https://github.com/yinhui1984/HelloTruffle ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:0:0","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"使用traffle套件 ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:0","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"1. 安装node.js https://nodejs.org/en/ 安装完成后, 查看是否版本以确保成功 npm -v node -v ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:1","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"2. 安装truffle和Ganache truffle是一套智能合约的开发测试环境 Ganache用于创建测试链(可以创建ETH FILECOIN等测试链), 用来跑自己创建的合约. https://trufflesuite.com 使用npm安装truffle npm install -g truffle 安装完成后, 查看版本以确保成功 truffle version 如果遇到permission denied: truffle 找到truffle文件 ll /usr/local/bin/truffle 可以看到其软连接到cli.bundled.js Permissions Size User Date Modified Name lrwxr-xr-x 48 zhouyinhui 29 Jun 14:06  /usr/local/bin/truffle -\u003e ../lib/node_modules/truffle/build/cli.bundled.js 给这个js加上执行权限即可 chmod +x /usr/local/lib/node_modules/truffle/build/cli.bundled.js 安装Ganache 到这里直接下载即可 https://trufflesuite.com/ganache/ ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:2","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"3. 使用truffle新建项目 新建一个目录, 比如~/Downloads/truffleTest 到这个目录下 OSX MP16 ~/Downloads/truffleTest ❯ truffle init Starting init... ================ \u003e Copying project files to /Users/zhouyinhui/Downloads/truffleTest Init successful, sweet! Try our scaffold commands to get started: $ truffle create contract YourContractName # scaffold a contract $ truffle create test YourTestName # scaffold a test http://trufflesuite.com/docs 其新建了这些文件 OSX MP16 ~/Downloads/truffleTest ❯ tree . ├── contracts │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js contracts文件夹存放合约的地方, 在其中新建一个solidity源码文件, 比如Calculator.sol touch ./contracts/Calculator.sol 在Calculator.sol中添加如下代码来做个加减法 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Calculator { function add(int a, int b) public pure returns (int) { return a + b; } function subtract(int a, int b) public pure returns (int) { return a - b; } } 其中的pure表示改函数既不读也不写状态机变量 https://hashnode.com/post/pure-vs-view-in-solidity-cl04tbzlh07kaudnv1ial1gio 复制上面代码时注意 pragma solidity ^0.8.0;这一行和 trffle-config.js中的下面的配置相匹配 // Configure your compilers compilers: { solc: { version: \"0.8.15\", //.... }, } pragma solidity ^0.8.0 表示编译器使用0.8到0.9版本之间的(不包含0.9), 那么trffle-config.js中配置的编译器版本要在这个范围内 ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:3","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"4.编译 truffle compile OSX MP16 ~/Downloads/truffleTest ❯ truffle compile Compiling your contracts... =========================== \u003e Compiling ./contracts/Calculator.sol \u003e Artifacts written to /Users/zhouyinhui/Downloads/truffleTest/build/contracts \u003e Compiled successfully using: - solc: 0.8.15+commit.e14f2714.Emscripten.clang 编译完成后, 会将结果放到build目录下: 我们这里关心的是Calculator.json OSX MP16 ~/Downloads/truffleTest ❯ tree . ├── build │ └── contracts │ ├── Calculator.json │ └── Migrations.json ├── contracts │ ├── Calculator.sol │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js 5 directories, 6 files ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:4","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"5.部署到测试链 启动测试链 启动 ganache App, 点击QUICKSTART 其就自动创建了ETH测试链, 查看窗口上半部分显示的的RPC server信息, 比如 HTTP://127.0.0.1:8545 修改 truffle-config.js中的部署配置, 使其与上面的RPC server向匹配 networks: { //... development: { host: \"127.0.0.1\", // Localhost (default: none) port: 8545, // Standard Ethereum port (default: none) network_id: \"*\", // Any network (default: none) }, Note 请保持ganache在后台运行, 后面的代码都需要访问测试链 添加部署代码 touch migrations/2_deploy_contracts.js 在2_deploy_contracts.js中加入如下代码 var Calculator = artifacts.require(\"./Calculator.sol\"); module.exports = function(deployer) { deployer.deploy(Calculator); } 部署合约 运行 truffle migrate 命令进行部署 OSX MP16 ~/Downloads/truffleTest ❯ truffle migrate Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. Starting migrations... ====================== \u003e Network name: 'development' \u003e Network id: 5777 \u003e Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- \u003e transaction hash: 0xc4b0bf65cbac8d1cf68b72fc6408bd443c18e6bf3e44c5985dede50b191a80d1 \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0xe2fd5fA1303B9791417EF637AABd50aE9DB9Af44 \u003e block number: 1 \u003e block timestamp: 1656490514 \u003e account: 0xe149d5f732685669C9E494B233fDB4312d19b5cF \u003e balance: 99.99502292 \u003e gas used: 248854 (0x3cc16) \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00497708 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00497708 ETH 2_deploy_contracts.js ===================== Deploying 'Calculator' ---------------------- \u003e transaction hash: 0xc8cce4b870d187dadf38353e6ef71aabd0751375a2f2b8c763ed4a35d8067a0c \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0x6B62e4E253823FBC65E0B93d63ee149350158a18 \u003e block number: 3 \u003e block timestamp: 1656490515 \u003e account: 0xe149d5f732685669C9E494B233fDB4312d19b5cF \u003e balance: 99.98984578 \u003e gas used: 216344 (0x34d18) \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00432688 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00432688 ETH Summary ======= \u003e Total deployments: 2 \u003e Final cost: 0.00930396 ETH ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:5","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"6. 测试合约 使用truffle console 手动调用 运行 truffle console 打开控制台 truffle(development)\u003e let cal = await Calculator.deployed() truffle(development)\u003e cal.add(1,2) BN { negative: 0, words: [ 3, \u003c1 empty item\u003e ], length: 1, red: null } truffle(development)\u003e cal.subtract(10, 2) BN { negative: 0, words: [ 8, \u003c1 empty item\u003e ], length: 1, red: null } 在控制台中可以使用TAB按键来提示成员变量或函数 使用js编写单元测试 touch test/testCalculator.test.js //testCalculator.test.js //开发框架导入合约 const Calculator = artifacts.require(\"Calculator\"); //接下来，我们定义用于测试的合约，然后将账户作为包含所有地址的参数传递。 contract(\"Calculator\", accounts =\u003e { //it包含对我们要运行的测试的简短描述， // 它是一个包含所有测试相关脚本的异步函数 it(\"should add two numbers\", async () =\u003e { //cal: 定义存储已部署合约的实例。 const cal = await Calculator.deployed(); const result = await cal.add(4, 2); assert.equal(result.toNumber(), 6); }).timeout(10000); it(\"should subtract two numbers\", async () =\u003e { const cal = await Calculator.deployed(); const result = await cal.subtract(3, 2); assert.equal(result.toNumber(), 1); }).timeout(10000); }); 运行 truffle test 跑测试 OSX MP16 ~/Downloads/truffleTest ❯ truffle test Using network 'development'. Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. Contract: Calculator ✔ should add two numbers ✔ should subtract two numbers (48ms) 2 passing (126ms) ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:6","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"7. demoApp调用合约 使用web3.js 我们使用web3.js 创建一个app来实际使用我们的合约 初始化一个node.js app mkdir -p ./demo/jsApp cd ./demo/jsApp/ npm init 然后一路默认回车 touch index.js 安装web3.js npm install web3 在index.js中加入如下代码 const Web3 = require('web3'); //注意，这里有个坑， 有时候http://localhost:8545 用localhost可以，有时候连接不上 //最好用127.0.0.1 const web3 = new Web3(new Web3.providers.HttpProvider(\"http://127.0.0.1:8545\")); //web3.eth.getAccounts().then(console.log) //modify the following line to your own contract address let contractAddress = \"0x6B62e4E253823FBC65E0B93d63ee149350158a18\"; //copy abi from ./build/contracts/Calculator.json let abi = [ { \"inputs\": [ { \"internalType\": \"int256\", \"name\": \"a\", \"type\": \"int256\" }, { \"internalType\": \"int256\", \"name\": \"b\", \"type\": \"int256\" } ], \"name\": \"add\", \"outputs\": [ { \"internalType\": \"int256\", \"name\": \"\", \"type\": \"int256\" } ], \"stateMutability\": \"pure\", \"type\": \"function\", \"constant\": true }, { \"inputs\": [ { \"internalType\": \"int256\", \"name\": \"a\", \"type\": \"int256\" }, { \"internalType\": \"int256\", \"name\": \"b\", \"type\": \"int256\" } ], \"name\": \"subtract\", \"outputs\": [ { \"internalType\": \"int256\", \"name\": \"\", \"type\": \"int256\" } ], \"stateMutability\": \"pure\", \"type\": \"function\", \"constant\": true } ] let contract = new web3.eth.Contract(abi,contractAddress); contract.methods.add(4,2).call().then(console.log); contract.methods.subtract(3,2).call().then(console.log); 其中的 contractAddress是我们部署的Caculator合约地址 如何找到合约地址? 方式1, 在上面的truffle migrate进行合约部署时,会打印 方式2, 在Ganache软件界面的Transactions中找, 貌似不方便 方式3, 在Ganache软件界面 : Settings -\u003e Workspace 中点击ADD Project 添加 truffle-config.js文件关联项目, 然后点击RESTART重新回到主界面的CONTRACTS就可以看到了 方式4, 运行truffle console truffle(development)\u003e Calculator.address '0x6B62e4E253823FBC65E0B93d63ee149350158a18' 其中的abi是合约对应的abi 如何找到abi? 方式1, solc --abi ./contracts/Calculator.sol 方式2, 到./build/contracts/Calculator.json中, 找到\"abi\"对应的值 不要使用truffle console中的Calculator.abi 运行app OSX MP16 ~/Downloads/truffleTest/demo/jsApp ❯ node index.js 6 1 使用golang mkdir -p ./demo/goApp cd ./demo/goApp touch main.go go mod init goApp 需要使用到 \"github.com/ethereum/go-ethereum/ethclient\"这个包 go get \"github.com/ethereum/go-ethereum/ethclient\" 这个包如果要调用合约, 则需要一些额外的操作 额外的操作: 利用 abigen 从solidity源文件生成golang代码 OSX MP16 ~/Downloads/truffleTest/demo/goApp ❯ mkdir contracts abigen --pkg contracts --sol ../../contracts/Calculator.sol --out ./contracts/calculatorContract.go –pkg contracts : 指定生成的代码的 package name –sol ../../contracts/Calculator.sol : 指定合约代码位置 –out ./contracts/calculatorContract.go: 指定生成的代码位置 生成完成后, goApp的目录结构如下: tree ~/Downloads/truffleTest/demo/goApp /Users/zhouyinhui/Downloads/truffleTest/demo/goApp ├── contracts │ └── calculatorContract.go ├── go.mod ├── go.sum └── main.go 生成后的calculatorContract.go中import包,可能并不在go.mod中, 所以运行一次 go mod tidy以避免编译时找不到包 main.go中代码如下: package main import ( \"fmt\" \"github.com/ethereum/go-ethereum/accounts/abi/bind\" \"github.com/ethereum/go-ethereum/common\" \"github.com/ethereum/go-ethereum/ethclient\" \"goApp/contracts\" \"math/big\" ) //https://goethereumbook.org/client-setup/ func main() { client, err := ethclient.Dial(\"http://localhost:8545\") if err != nil { fmt.Println(\"could not connect to local node, err:\", err) return } contractAddress := common.HexToAddress(\"0x6B62e4E253823FBC65E0B93d63ee149350158a18\") calculator, err := contracts.NewCalculator(contractAddress, client) if err != nil { fmt.Println(\"could not instantiate contract, err:\", err) return } callOpts := bind.CallOpts{ Context: nil, Pending: false, } a := big.NewInt(1) b := big.NewInt(2) result, err := calculator.Add(\u0026callOpts, a, b) if err != nil { fmt.Println(\"could not call contract, err:\", err) return } fmt.Println(\"add result:\", result) result, err = calculator.Subtract(\u0026callOpts, a, b) if err != nil { fmt.Println(\"could not call contract, err:\", err) return } fmt.Println(\"subtract result:\", result) } 运行 OSX MP16 ~/Downloads/truffleTest/demo/goApp ❯ go run . add result: 3 subtract result: -1 ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:7","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"手工撸 Coming Soon…. ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:2:0","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["golang"],"content":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:0:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"一个简单的DEMO package main import \"fmt\" var ( sharedCounter = 0 ) func add(count int) { for i := 0; i \u003c count; i++ { sharedCounter++ } } func sub(count int) { for i := 0; i \u003c count; i++ { sharedCounter-- } } func show() { fmt.Println(sharedCounter) } func main() { add(1000000) sub(1000000) show() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器. add函数在计数器上循环添加一定的数值, sub则相反, show则是打印计数器当前的值. 程序运行结束后, sharedCounter应该为0, 上面代码的输出的确如此. ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:1:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"使用一个协程 如果对计数器进行加减的调用在不同的协程里面, 会怎么样呢? func main() { add(1000000) go sub(1000000) show() } 会得到1000000 , 因为go sub(1000000)刚启动, 程序就退出了. 或许我们应该等到sub函数执行结束 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:2:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"等待协程结束 错误的方式 如果有C语言开发背景, 可能会想到通过设置一个flag来指示运算是否结束, 比如: func sub(count int, done *bool) { for i := 0; i \u003c count; i++ { sharedCounter-- } *done = true } //.... func main() { add(1000000) done := false go sub(1000000, \u0026done) for !done { time.Sleep(time.Millisecond * 10) } show() } 这虽然也能得到正确的输出, 但非常不优雅. 正确的方式1 可以使用一个无缓冲的信道(或者说容量为1的信道)来充当flag //... func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { sharedCounter-- } done \u003c- true } //.... func main() { add(1000000) done := make(chan bool) go sub(1000000, done) \u003c-subDone show() } 这里利用了信道的特点: 当从信道中读取数据时,如果信道为空,读取将被阻塞直到有数据到达. 所以 \u003c-subDone 会一直阻塞, 直到通过subDone \u003c- true向其中写入了数据 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:2:1","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"使用2个协程 上面的例子中, sub(1000000, done)是在新的协程中运行的, add(1000000)却不是, 如果他们都在新协程中运行, 主程序应该如何等待他们结束呢 很容易想到, 使用两次\u003c-done 也就是说向信道索要两个计算完成的标志, add和 sub 计算完成后分别向其中放入标志. package main import \"fmt\" var ( sharedCounter = 0 ) func add(count int, done chan bool) { for i := 0; i \u003c count; i++ { sharedCounter++ } fmt.Println(\"add done\") done \u003c- true } func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { sharedCounter-- } fmt.Println(\"sub done\") done \u003c- true } func show() { fmt.Println(sharedCounter) } func main() { done := make(chan bool) go add(1000000, done) go sub(1000000, done) \u003c-done \u003c-done show() } 为了明确知道main函数的确是等待两个协程执行完毕了的, 我们在其中加入了fmt.Println(\"sub done\")这样的输出 运行程序, 得到 add done sub done 824933 Opps, 虽然add和sub 都执行完毕了,但是结果不对(并且多次运行的结果还不相同), 期望接收应该是0 再运行一次, 得到: sub done add done -481342 原因是add和sub在交叉读取和写入sharedCounter这个变量, 他们共享了变量, 但在读取和写入的时候出现**“竞态”** ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"竞态 有多个协程运行时, 对于每个协程而言,其内部代码时顺序执行的, 但无法确定协程之间的执行顺序, 那么就说这些协程是并发的 如果一段代码无论是顺序执行还是并发执行,其结果都是确定的,那么这个代码就是并发安全的. 相反, 并发不安全的代码,可能会出现死锁,活锁,竞态 竞态则表示代码可执行,但可能出现结果不一致(错误结果) ###解决方法1, 利用信道 func main() { done := make(chan bool) go add(1000000, done) \u003c-done //1 go sub(1000000, done) \u003c-done //2 show() } 在add执行完毕之前, 首先会堵塞在//1处, func add(count int, done chan bool) { //.... done \u003c- true } add函数执行最后一句 done \u003c- true 后 \u003c-done //1能取到值, 接触阻塞. 然后继续往下执行sub函数. 这虽然能得到正确输出, 但, 我们发现, 这实际是将并行执行修改成了串行执行. ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:1","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"解决方法2, 利用 Mutex 或 RWMutex sync.Mutex 可能是同步包中使用最广泛的原语。它允许对共享资源进行互斥（不能同时访问). mutex := \u0026sync.Mutex{} mutex.Lock() //.... 更新共享变量 mutex.Unlock() 注意: 在官方文档中有这么一句 “Values containing the types defined in this package should not be copied.” (“包含这个包中定义的类型的值不应该被复制。”) . 我们直到值传递就是复制然后传递, 所以我们代码中的mutex用的是引用传递. package main import ( \"fmt\" \"sync\" ) var ( sharedCounter = 0 mutex = \u0026sync.Mutex{} ) func add(count int, done chan bool) { for i := 0; i \u003c count; i++ { mutex.Lock() sharedCounter++ mutex.Unlock() } fmt.Println(\"add done\") done \u003c- true } func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { mutex.Lock() sharedCounter-- mutex.Unlock() } fmt.Println(\"sub done\") done \u003c- true } func show() { fmt.Println(sharedCounter) } func main() { done := make(chan bool) go add(1000000, done) go sub(1000000, done) \u003c-done \u003c-done show() } 在读写sharedCounter之前先Lock(), 用完后Unlock() 如果我们在进行计算的时候加上点打印(仅测试用,非常影响速度) for i := 0; i \u003c count; i++ { mutex.Lock() fmt.Println(\"--\") // fmt.Println(\"++\") sharedCounter-- // sharedCounter++ mutex.Unlock() } 则可以看到 ++ 和 – 是交叉着打印的, 说明是并行执行的. 另外, 还有RWMutex (读写锁), 除了与Mutex相同的Lock()和Unlock()方法外, 其还有用于共享读操作的RLock()和RUnlock(), 在读取共享变量时允许同时多个读取器能提高效率. 所以在频繁读写操作的代码中, 使用RWMutex效率要比Mutex高 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:2","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"解决方法3, 利用原子操作 原子操作在\"sync/atomic\"包中. 利用这个包中提供的函数可实现\"无锁版\"的共享变量读写 原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作 package main import ( \"fmt\" \"sync/atomic\" ) var ( sharedCounter = int64(0) ) func add(count int, done chan bool) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, 1) // } fmt.Println(\"add done\") done \u003c- true } func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, -1) // } fmt.Println(\"sub done\") done \u003c- true } func show() { fmt.Println(sharedCounter) } func main() { done := make(chan bool) go add(1000000, done) go sub(1000000, done) \u003c-done \u003c-done show() } 原子操作的常用接口如下(以int32为例) //将addr指向的值和old进行比较, 如果相等,则将new赋值到addr指向的位置,并返回true, 如果不相等,则直接返回false func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) //使用原子操作,将addr指向的位置增加一个delta func AddInt32(addr *int32, delta int32) (new int32) //原子读取 //当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。 func LoadInt32(addr *int32) (val int32) //读取是有原子性的操作的，同样写入atomic包也提供了相关的操作包 func StoreInt32(addr *int32, val int32) //此类型的值相当于一个容器，可以被用来“原子地\"存储（Store）和加载（Load）任意类型的值。当然这个类型也是原子性的。 //有了atomic.Value这个类型，这样用户就可以在不依赖Go内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。 // A Value must not be copied after first use. type Value struct { v interface{} } 原子操作与互斥锁的区别 首先atomic操作的优势是更轻量，比如CAS可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。 原子操作也有劣势。还是以CAS操作为例，使用CAS操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。 下面是几点区别： 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作 原子操作是无锁的，常常直接通过CPU指令直接实现 原子操作中的cas趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理 可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程 不要轻易使用atomic https://texlution.com/post/golang-lock-free-values-with-atomic-value/ ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:3","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"其它并发控制方法 上面的例子中, 我们都是使用的信道来进行并发控制 (done \u003c- true与\u003c-done), 这只是常用的方法之一 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:4:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"WaitGroup sync.WaitGroup 拥有一个内部计数器。如果此计数器等于 0，则 Wait() 方法立即返回。否则，它将被阻塞，直到计数器为 0。 要增加计数器，我们必须使用 Add(int)。要减少它，我们可以使用 Done() （将减少 1）或具有负值的相同 Add(int) 方法。 package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) var ( sharedCounter = int64(0) ) func add(count int, wg *sync.WaitGroup) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, 1) } fmt.Println(\"add done\") wg.Done() } func sub(count int, wg *sync.WaitGroup) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, -1) } fmt.Println(\"sub done\") wg.Done() } func show() { fmt.Println(sharedCounter) } func main() { wg := sync.WaitGroup{} wg.Add(2) go add(1000000, \u0026wg) go sub(1000000, \u0026wg) wg.Wait() show() } 注意:传递 WaitGroup时要使用引用传递(指针), 其不应该被复制. func sub(count int, wg *sync.WaitGroup) ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:4:1","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"context.Context Context提供了2个功能 控制子协程结束 传递值 其不在sync包中, 后面专门讲 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:4:2","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Pool 对象复用 其提供一个\"并发安全\"的可复用的对象池. 用来减少频繁GC所代理的压力. 其大概意思是: 如果有旧对象可用,则用旧的, 没有再New一个 参考这批文章: https://www.cnblogs.com/qcrao-2018/p/12736031.html 以及这里 https://geektutu.com/post/hpg-sync-pool.html 在实际开发工作中, 不要一上来就想做使用sync.Pool它通常会带来问题(因为其Get出来的对象的状态是不确定的), 而应该遵循下面的原则: 根据你收集到的需求设计你的代码（不要跳过这个步骤）。 编写最简单、最清晰、最愚蠢的设计实现。 如果客户满意，就停止 如果客户不满意，而且他们认为应用程序的性能不能满足他们的要求，那么就剖析。 解决最高性能的主导者 剖析并进入第五阶段。然后进入3 如果实在搞不定, 再想想sync.Pool ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:5:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Once 只执行一次 sync.Once 提供了一种方法, 让相关代码只被执行一次 实际开发过程中, 经常有这样的场景: 你做了一个叫做lowLevelApi的包, 用于控制底层设备, 比如开关LED, 但在调用开关LED之前需要确保一些初始化工作已经完成, 所以你写了一个InitEnv的函数, 并告诉其它开发人员: 一定要先初始化哦. package lowLevelApi import \"fmt\" func InitEnv() { fmt.Println(\"init environment\") } func LedOn() { fmt.Println(\"LedOn\") } func LedOff() { fmt.Println(\"LedOff\") } 其它开发人员经常会问你: 这个初始化函数如果被重复调用不会出问题吧? 因为他们的代码通常会这样写: package main import ( \"fmt\" \"goplayground/lowLevelApi\" ) func turnLedOn() { fmt.Println(\"Turning LED on\") lowLevelApi.InitEnv() lowLevelApi.LedOn() fmt.Println(\"LED on\") } func turnLedOff() { fmt.Println(\"Turning LED off\") lowLevelApi.InitEnv() lowLevelApi.LedOff() fmt.Println(\"LED off\") } func main() { turnLedOn() turnLedOff() } 上面的代码会输出 Turning LED on InitEnv LedOn LED on Turning LED off InitEnv LedOff LED off 为了防止重复调用InitEnv()可能带来的问题, 则可以使用sync.Once var ( once sync.Once ) func InitEnv() { once.Do(func() { fmt.Println(\"InitEnv\") }) } 这样InitEnv()即使被多次调用, 其内部逻辑只会执行一次 Turning LED on InitEnv LedOn LED on Turning LED off LedOff LED off sync.Once 常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。 init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。 sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:6:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Cond 条件变量 sync.Cond 用于协调多个协程访问共享资源, 其中某些协程处于阻塞状态, 另外一个协程在条件准备好的时候来讲其它协程唤醒. 下面的例子中 InitEnv函数需要一点时间在准备sharedCounter 的初始值, 在这期间Add和sub处于Wait状态, 当准备好后, 将通知 Add和Sub继续向下执行 package main import ( \"fmt\" \"sync\" \"time\" ) var ( sharedCounter int ) func InitEnv(c *sync.Cond) { fmt.Println(\"begin InitEnv\") time.Sleep(time.Second * 1) c.L.Lock() sharedCounter = 10 c.L.Unlock() fmt.Println(\"Init Env Done, broadcast...\") c.Broadcast() } func Add(cout int, c *sync.Cond) { c.L.Lock() c.Wait() sharedCounter += cout c.L.Unlock() fmt.Println(\"Add Done\") } func Sub(count int, c *sync.Cond) { c.L.Lock() c.Wait() sharedCounter -= count c.L.Unlock() fmt.Println(\"Sub Done\") } func main() { cond := sync.NewCond(\u0026sync.Mutex{}) go InitEnv(cond) go Add(5, cond) go Sub(2, cond) time.Sleep(2 * time.Second) fmt.Println(\"Final Counter:\", sharedCounter) } 输出 begin InitEnv Init Env Done, broadcast... Add Done Sub Done Final Counter: 13 c.Broadcast()唤醒所有等待的协程, 另外还有一个Signal()方法, 用于唤醒一个协程. sync.Cond一般用于一对多的情况, 如果是一对一的情况, 用一个信道就可以轻松解决了 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:7:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Map 内置的map不是并发安全的, 所以 sync.Map 提供了一个功能与map类似但是并发安全的版本 可以参考这篇文章 https://juejin.cn/post/6844903895227957262 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:8:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"go语言中net/http包对http服务与请求的处理 ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"简单的文件服务器 package main import ( \"log\" \"net/http\" ) func main() { err := http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\".\"))) if err != nil { log.Fatal(err) } } 上面这个例子创建了一个以当前目录为站点跟目录的文件服务器, 我一般用这个来作为局域网文件共享. 然后写一个函数放到bash.rc 或zshrc中 #文件服务器 function fileserver(){ echo \"start file server :12345\" cat \u003c\u003cEOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \"log\" \"net/http\" ) func main() { err := http.ListenAndServe(\":12345\", http.FileServer(http.Dir(\".\"))) if err != nil { log.Fatal(err) } } EOF } OSX MP16 ~/Downloads ❯ fileserver start file server :12345 Python中有相同的功能 python3 -m SimpleHTTPServer 7777 或 python3 -m http.server ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"一个简单的WebServer package main import ( \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { _, err := w.Write([]byte(\"Hello World!\\n\")) if err != nil { log.Println(err) } }) err := http.ListenAndServe(\":12345\", nil) if err != nil { log.Fatal(err) } } 访问一下试试: OSX MP16 ~/Downloads/goplayground ❯ curl http://localhost:12345 Hello World! ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"http.HandleFunc http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { //... }) 该方法提供了一种指定如何处理特定路由的请求的方法, 第一个参数为路由, 第二个参数为处理函数. 处理函数可写成匿名函数, 也可以声明为一个独立的函数 func rootHandler(w http.ResponseWriter, r *http.Request) { _, err := w.Write([]byte(\"\u003ch1 style=\\\"color:Tomato;\\\"\u003eHello World\u003c/h1\u003e\")) if err != nil { log.Println(err) } } func main() { http.HandleFunc(\"/\", rootHandler) //... } 函数的第一个参数是http.ResponseWriter类型的值。这是用于向任何连接的HTTP客户端发送响应的机制。这也是响应标头的设置方式,比如w.WriteHeader(http.StatusOK)。第二个论点是指向http.Request的指针。这是从网络请求中检索数据的方式。例如，可以通过请求指针访问表单提交的详细信息 比如 下面的方法, 使用 http://127.0.0.1:12345/?key=date 时将返回当前的日期, 确实key=或key不正确时返回http.StatusBadRequest func rootHandler(w http.ResponseWriter, r *http.Request) { keys, ok := r.URL.Query()[\"key\"] if !ok || len(keys[0]) \u003c 1 { log.Println(\"Url Param 'key' is missing\") w.WriteHeader(http.StatusBadRequest) _, err := w.Write([]byte(\"Url Param 'key' is missing\")) if err != nil { log.Println(err) return } return } key := keys[0] switch key { case \"date\": w.WriteHeader(http.StatusOK) _, err := w.Write([]byte(time.Now().Format(\"2006-01-02\"))) if err != nil { log.Println(err) } default: w.WriteHeader(http.StatusBadRequest) _, _ = w.Write([]byte(\"Invalid key\")) log.Println(\"Invalid key\") } } ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"http.ResponseWriter 用于向任何连接的HTTP客户端发送响应 设置相应标志头: w.WriteHeader(http.StatusOK) 获取或实则响应头 w.Header().Set(\"content-type\", \"application/json\") w.Header().Add(\"foo\", \"bar\") 写入相应数据: w.Write([]byte(time.Now().Format(\"2006-01-02\"))) 例子: package main import ( \"encoding/json\" \"log\" \"net/http\" ) type SystemInfo struct { Hostname string `json:\"hostname\"` Uptime string `json:\"uptime\"` } func rootHandler(w http.ResponseWriter, r *http.Request) { info := SystemInfo{ Hostname: \"test\", Uptime: \"2022-01-01 00:00:00\", } w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) bytes, _ := json.Marshal(info) _, err := w.Write(bytes) if err != nil { log.Println(\"Error writing response: \", err) } } func main() { http.HandleFunc(\"/\", rootHandler) err := http.ListenAndServe(\":12345\", nil) if err != nil { log.Fatal(err) } } OSX MP16 ~ ❯ curl localhost:12345 {\"hostname\":\"test\",\"uptime\":\"2022-01-01 00:00:00\"} ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:1","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"*http.Request 指向http.Request的指针, 通过改指针可以获取请求中的各种数据, 比如 获取基本信息 func rootHandler(w http.ResponseWriter, r *http.Request) { fmt.Println(\"User Agent: \", r.UserAgent()) fmt.Println(\"Host: \", r.Host) fmt.Println(\"Remote Address: \", r.RemoteAddr) fmt.Println(\"Request URI: \", r.RequestURI) fmt.Println(\"Method: \", r.Method) fmt.Println(\"URL: \", r.URL) fmt.Println(\"Header: \", r.Header) w.WriteHeader(http.StatusOK) } 输出: User Agent: curl/7.79.1 Host: localhost:12345 Remote Address: 127.0.0.1:58967 Request URI: / Method: GET URL: / Header: map[Accept:[*/*] User-Agent:[curl/7.79.1]] 获取cookie func rootHandler(w http.ResponseWriter, r *http.Request) { //获取所有 for _, c := range r.Cookies() { fmt.Printf(\"%s : %q\\n\", c.Name, c.Value) } //获取指定 c, err := r.Cookie(\"token\") if err != nil { log.Println(err) } fmt.Printf(\"%s : %q\\n\", c.Name, c.Value) w.WriteHeader(http.StatusOK) } curl --cookie \"token=abcdefg\" http://localhost:12345 获取GET参数 获取所有参数 args := r.URL.Query() 获取指定参数(注:参数可能被重复写多次) 比如: localhost:12345/?id=5 func rootHandler(w http.ResponseWriter, r *http.Request) { ids, ok := r.URL.Query()[\"id\"] if !ok || len(ids[0]) \u003c 1 { log.Println(\"Url Param 'id' is missing\") return } id := ids[0] log.Println(\"Url Param 'id' is: \" + id) w.WriteHeader(http.StatusOK) } 或者 func rootHandler(w http.ResponseWriter, r *http.Request) { id := r.FormValue(\"id\") if id == \"\" { log.Println(\"Url Param 'id' is missing\") } fmt.Println(\"id:\", id) w.WriteHeader(http.StatusOK) } 也可以通过r.Form来获取Get参数 获取PATCH, POST or PUT参数 比如 curl -d \"id=5\u0026format=1\" http://localhost:12345/ func rootHandler(w http.ResponseWriter, r *http.Request) { //parse err := r.ParseForm() if err != nil { log.Println(\"ParseForm error:\", err) } //get post args for k, v := range r.PostForm { log.Println(\"key:\", k) log.Println(\"val:\", v) // v []string } w.WriteHeader(http.StatusOK) } 输出 2022/06/06 15:14:46 key: id 2022/06/06 15:14:46 val: [5] 2022/06/06 15:14:46 key: format 2022/06/06 15:14:46 val: [1] ParseForm会填充r.Form和r.PostForm。 对于所有的请求，ParseForm解析来自URL的原始查询并更新r.Form。 对于POST、PUT和PATCH请求，它也读取请求正文，将其解析为一个表单，并将结果放入r.PostForm和r.Form中。在r.Form中，请求正文参数优先于URL查询字符串值。 如果请求体的大小还没有被MaxBytesReader限制，那么其大小将被限制在10MB。 对于其他HTTP方法，或者当内容类型不是application/x-www-form-urlencoded时，请求正文不被读取，并且r.PostForm被初始化为一个非零的空值。 ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。 r.Form属性包含了post表单和url中的get参数。 r.PostForm属性只包含了post表单参数。 获取指定参数, 比如 func rootHandler(w http.ResponseWriter, r *http.Request) { err := r.ParseForm() if err != nil { log.Println(\"ParseForm error:\", err) } ids := r.PostForm.Get(\"id\") //获取id参数的第一个值 log.Println(\"id:\", ids) w.WriteHeader(http.StatusOK) } 或者 func rootHandler(w http.ResponseWriter, r *http.Request) { id := r.PostFormValue(\"id\") if id == \"\" { log.Println(\"Url Param 'id' is missing\") } fmt.Println(\"id:\", id) w.WriteHeader(http.StatusOK) } 获取上传文件 比如 curl -F \"file=@IMG_1526.PNG;type=image/png\" http://localhost:12345/upload 下面代码中: r.ParseMultipartForm(10 \u003c\u003c 20)将一个请求体解析为multipart/form-data。整个请求正文被解析，并且其文件部分最多存储在maxMemory字节的内存中，其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。如果ParseForm返回一个错误，ParseMultipartForm将其返回，但也继续解析请求正文。在对ParseMultipartForm进行一次调用后，随后的调用没有任何影响. FormFile 返回提供的表单key的第一个文件。如果需要，FormFile会调用ParseMultipartForm和ParseForm。 package main import ( \"io\" \"log\" \"mime/multipart\" \"net/http\" \"os\" ) func uploadHandler(w http.ResponseWriter, r *http.Request) { // Parse the multipart form in the request err := r.ParseMultipartForm(10 \u003c\u003c 20) // 10 MiB if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } // FormFile returns the first file for the given key `file` // it also returns the FileHeader, so we can get the Filename, the Header and the size of the file file, handler, err := r.FormFile(\"file\") if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } defer func(file multipart.File) { err := file.Close() if err != nil { log.Println(err) } }(file) err = os.MkdirAll(\"./upload\", 0777) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) re","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:2","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"Handler , Handle , HandleFunc 与 http.ListenAndServe 使用默认的Handler 先看一个简单的例子 package main import \"net/http\" func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello, world!\")) }) http.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is my Blog\")) }) http.ListenAndServe(\":12345\", nil) } 在启动一个HttpServer的时候, 其实我们就关心2个东西: 地址 路由: 将请求对应到相应的处理函数中去 这两个参数 在http.ListenAndServe(\":12345\", nil)中进行设置的, 第一个为地址, 第二个传递处理函数. 如果传递nil, 则采用默认的 The handler is typically nil, in which case the DefaultServeMux is used. http.ListenAndServe的实现如下: func ListenAndServe(addr string, handler Handler) error { server := \u0026Server{Addr: addr, Handler: handler} return server.ListenAndServe() } type Handler interface { ServeHTTP(ResponseWriter, *Request) } 可以看到 Handler是一个接口, 实现这个接口的话, 我们可以创建自己的Handler 自定义Handler 定义一个结构体, 结构体实现 ServeHTTP(w http.ResponseWriter, r *http.Request)方法 然后使用 Handle函数进行路由注册 package main import \"net/http\" type MyIndexHandler struct { } func (h *MyIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello World\")) } type MyBlogHandler struct { } func (h *MyBlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is my Blog\")) } func main() { mux := http.NewServeMux() mux.Handle(\"/\", \u0026MyIndexHandler{}) mux.Handle(\"/blog\", \u0026MyBlogHandler{}) http.ListenAndServe(\":12345\", mux) } OSX MP16 ~ ❯ curl localhost:12345 Hello World OSX MP16 ~ ❯ curl localhost:12345/blog This is my Blog OSX MP16 ~ ❯ 但这明显看出来, 对每一个路由 都要高写一个xxxHandler结构体和实现ServeHTTP, 看上去非常混乱 这时候就可以用mux.HandleFunc来实现路由 package main import \"net/http\" func main() { mux := http.NewServeMux() mux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello World\")) }) mux.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is my Blog\")) }) http.ListenAndServe(\":12345\", mux) } 自定义ServeMux 在上面的例子中, mux := http.NewServeMux()还是使用了默认router, 其简单的同时也有不少缺点 比如, 其是通过url进行路由, 但不支持基于方法(GET, POST…)的路由, 不支持正则表达式等等 参考这个 https://www.alexedwards.net/blog/which-go-router-should-i-use ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:3","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"人气Web框架 参考这篇文章, https://blog.51cto.com/coderaction/3001008 其中有各框架的对比, 功能上iris最全 https://github.com/kataras/iris ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]