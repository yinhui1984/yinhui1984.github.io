[{"categories":["windows"],"content":"如何使用Visual Studio进行C++项目远程调试 这里说的是VS, 不是VS Code ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:0:0","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["windows"],"content":"普通的实践 一般的思路是, 在远程机器上安装VS远程调试工具. 将调试文件拷贝到远程机器. 但这会带来一下问题 本地机器修改了代码,重新编译后需要重新拷贝到远程机器 如果将代码放在远程, 本机访问远程机器的共享文件夹进行编码, 然后编译. 会带来问题: 如果编译的项目稍大, 编译超慢. hotload更是没法用 ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:1:0","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["windows"],"content":"最佳实践 思路: 本地机器共享文件夹, 远程机器公共访问共享文件夹来运行程序. 这样确保编译和运行在同一目录. 修改代码,编译,调试效率就会高很多. ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:0","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["windows"],"content":"拷贝remote debuger 到VS的安装目录下拷贝remote debuger C:\\Program Files\\Microsoft Visual Studio xxx\\Common7\\IDE\\Remote Debugger 假设下面你的目录结构如下: ./to_debug ├── RemoteDebugger │ └── x64 │ └── msvsmon.exe └── my_code └── debug └── app.exe ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:1","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["windows"],"content":"共享目录 将to_debug目录共享, 确保远程机器能访问改共享目录 假设本地ip为192.168.0.200 远程机器可以 \\\\192.168.0.200\\to_debug ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:2","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["windows"],"content":"运行msvsmon.exe 在远程机器上访问共享文件夹, 然后运行msvsmon.exe 第一次运行时会弹窗, 把能勾上的全勾上.然后在设置中选择’无需授权验证’和’超时时间’设置为0 , 0表示不超时. 运行后, 会看到: MSvsoon启动了名为XXXX的新服务器 XXXX是服务器名称和端口, 等会儿会用到 ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:3","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["windows"],"content":"配置项目 在VS解决方案资源管理器中, 右键用做启动项目的属性 配置属性 –\u003e 调试 –\u003e远程Windows调试器 配置: 远程命令: 在远程计算机上如何运行的你程序. 我们远程机器通过访问本地机器的共享目录来访问, 所以填写 \\\\192.168.0.200\\to_debug\\mycode\\debug\\app.exe 工作目录\\\\192.168.0.200\\to_debug\\mycode\\debug 远程服务名称: XXXX 就是上一步中的服务名称和端口, 例如 ADMIN-PC:4026 部署目录, 无需填写, 我们不需要部署和拷贝, 因为编译和运行本来就在同一目录 ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:4","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["windows"],"content":"调试 平时我们调试时绿色箭头旁边选择的时本地调试器, 这里切换成远程Windows调试器 ","date":"2022-07-27","objectID":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:5","tags":["vs","vc++"],"title":"Visual Studio VC++ 远程调试","uri":"/visutal-studio-%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":["golang"],"content":"go语言写的一个文件下载脚本 晚上想听点有声小说, 要两毛一集, 算了一下,一本书要几百块, 囊中羞涩, 于是拿出电脑搞个脚本 ","date":"2022-07-22","objectID":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/:0:0","tags":["http","downloader"],"title":"Golang文件下载","uri":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"categories":["golang"],"content":"单协程下载 package main import ( \"bufio\" \"io\" \"log\" \"net/http\" \"os\" ) func download(title string) { outputFile := \"./output/\" + title // if file exists, skip if _, err := os.Stat(outputFile); err == nil { log.Println(\"File exists, skip: \", outputFile) return } url := \"https://马赛克xxxx/牧神记/\" + title log.Println(\"Downloading: \", url) resp, err := http.Get(url) if err != nil { log.Println(\"error:\" + err.Error()) } defer func(Body io.ReadCloser) { err := Body.Close() if err != nil { log.Println(\"close body error:\" + err.Error()) } }(resp.Body) file, err := os.OpenFile(outputFile, os.O_CREATE|os.O_WRONLY, 0644) if err != nil { panic(err) } defer func(file *os.File) { err := file.Close() if err != nil { log.Println(\"close file error:\" + err.Error()) } }(file) _, err = io.Copy(file, resp.Body) if err != nil { log.Println(\"copy file error:\" + err.Error()) } //貌似不会封IP, 如果封ip可以使用 https://github.com/Python3WebSpider/ProxyPool //time.Sleep(time.Second * 3) } func main() { //mp3list.txt 从网站主页复制的小说每一集的标题列表 //0001_天黑别出门.mp3 //0002_四灵血.mp3 //0003_神通.mp3 //... //省略数千行 file, err := os.Open(\"mp3list.txt\") if err != nil { panic(err) } defer func(file *os.File) { _ = file.Close() }(file) //read file line by line scanner := bufio.NewScanner(file) for scanner.Scan() { title := scanner.Text() //download file download(title) } } ","date":"2022-07-22","objectID":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/:1:0","tags":["http","downloader"],"title":"Golang文件下载","uri":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"categories":["golang"],"content":"多协程下载 感觉单协程太慢, 20个协程同时下载多爽… golang实现起来超级简单 ","date":"2022-07-22","objectID":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/:2:0","tags":["http","downloader"],"title":"Golang文件下载","uri":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"categories":["golang"],"content":"golang chan 搞一个队列 var queue = make(chan int, 20) 下载前向队列里放一个元素 //download file queue \u003c- 1 go download(title) 队列最多放20个就会阻塞 下载完成或skip时就从队列中弹出 // if file exists, skip if _, err := os.Stat(outputFile); err == nil { log.Println(\"File exists, skip: \", outputFile) \u003c-queue return } //download finish \u003c-queue 队列为空时, 表示下载完成, 程序退出 for true { time.Sleep(time.Second * 2) //if queue is empty, exit if len(queue) == 0 { break } } ","date":"2022-07-22","objectID":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/:2:1","tags":["http","downloader"],"title":"Golang文件下载","uri":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"categories":["golang"],"content":"完整代码 package main import ( \"bufio\" \"io\" \"log\" \"net/http\" \"os\" \"time\" ) var queue = make(chan int, 20) func download(title string) { outputFile := \"./output/\" + title // if file exists, skip if _, err := os.Stat(outputFile); err == nil { log.Println(\"File exists, skip: \", outputFile) \u003c-queue return } url := \"https://马赛克xxxx/牧神记/\" + title log.Println(\"Downloading: \", url) resp, err := http.Get(url) if err != nil { log.Println(\"error:\" + err.Error()) } defer func(Body io.ReadCloser) { err := Body.Close() if err != nil { log.Println(\"close body error:\" + err.Error()) } }(resp.Body) file, err := os.OpenFile(outputFile, os.O_CREATE|os.O_WRONLY, 0644) if err != nil { panic(err) } defer func(file *os.File) { err := file.Close() if err != nil { log.Println(\"close file error:\" + err.Error()) } }(file) _, err = io.Copy(file, resp.Body) if err != nil { log.Println(\"copy file error:\" + err.Error()) } //貌似不会封IP, 如果封ip可以使用 https://github.com/Python3WebSpider/ProxyPool //time.Sleep(time.Second * 3) //download finish \u003c-queue } func main() { //open file mp3list.txt file, err := os.Open(\"mp3list.txt\") if err != nil { panic(err) } defer func(file *os.File) { _ = file.Close() }(file) //read file line by line scanner := bufio.NewScanner(file) for scanner.Scan() { title := scanner.Text() //download file queue \u003c- 1 go download(title) } for true { time.Sleep(time.Second * 2) //if queue is empty, exit if len(queue) == 0 { break } } } ","date":"2022-07-22","objectID":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/:2:2","tags":["http","downloader"],"title":"Golang文件下载","uri":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"categories":["golang"],"content":"代理池 我本次遇到的网站并没有WAF (Web Application Firewall), 所以可以狂下载 如果遇到被封IP的情况, 可以使用代理池: https://github.com/Python3WebSpider/ProxyPool ","date":"2022-07-22","objectID":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/:2:3","tags":["http","downloader"],"title":"Golang文件下载","uri":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"categories":["golang"],"content":"深入理解 欢迎阅读本博客中的 go语言中channel是如何工作的 ","date":"2022-07-22","objectID":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/:3:0","tags":["http","downloader"],"title":"Golang文件下载","uri":"/golang%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"},{"categories":["golang"],"content":"delve就是go语言的gdb delve就是go语言的gdb,虽然 gdb也可以调试go程序 (https://go.dev/doc/gdb). 但是, 用gdb调试go程序有这些已知问题: 已知问题 字符串pretty printing 只对字符串类型触发，而不是对其派生类型。 运行库的 C 部分缺少类型信息。 GDB 不理解 Go 的名称资格，并将 “fmt.Print “视为带有”. “的非结构化字面，需要加以引号。它对pkg.(*MyType).Meth形式的方法名反对得更厉害。 从Go 1.11开始，调试信息默认是压缩的。旧版本的gdb，例如MacOS上默认提供的版本，并不理解压缩。你可以使用go build -ldflags=-compressdwarf=false来生成未压缩的调试信息。(为了方便，你可以把-ldflags选项放在GOFLAGS环境变量中，这样你就不必每次都指定它)。 使用 delve https://github.com/go-delve/delve 更简单舒适 ","date":"2022-07-22","objectID":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/:0:0","tags":["delev","gdb"],"title":"使用delve对go代码进行调试","uri":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"},{"categories":["golang"],"content":"首次安装 go install github.com/go-delve/delve/cmd/dlv@latest ","date":"2022-07-22","objectID":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/:1:0","tags":["delev","gdb"],"title":"使用delve对go代码进行调试","uri":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"},{"categories":["golang"],"content":"基本使用 如果是调试主程序, cd到main.go所在目录, 运行 dlv debug 如果是调试测试代码, cd到*_test.go所在目录, 运行 dlv test 然后 和 gdb用法类似 break: 打断点 b packageName.functionName 或 b fileName:lineNumber 比如 b main.Add, b main.main continue: 开始执行或继续执行 c (开始执行也用c) next :执行下一行 n step: 单步进入 s stepout: 单步退出so print:打印 p thevar quit退出调试 q 更多的 https://github.com/go-delve/delve/blob/master/Documentation/cli/README.md ","date":"2022-07-22","objectID":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/:2:0","tags":["delev","gdb"],"title":"使用delve对go代码进行调试","uri":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"},{"categories":["golang"],"content":"高级使用 dlv attach - 附加到正在运行的进程并开始调试。 dlv connect - 用终端客户端连接到headless debug server。 dlv core - 检查一个核心转储。 dlv dap - 启动一个通过调试适配器协议（DAP）通信的无头TCP服务器。 dlv debug - 编译并开始调试当前目录下的主包，或指定的包。 dlv exec - 执行一个预编译的二进制文件，并开始一个调试会话。 dlv replay - 回放一个rr跟踪。 dlv run - 废弃的命令。使用’debug’代替。 dlv test - 编译测试二进制文件并开始调试程序。 dlv trace - 编译并开始追踪程序。 dlv version - 打印版本。 dlv log - 关于记录标记的帮助 dlv backend - --backend flag的帮助 ","date":"2022-07-22","objectID":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/:3:0","tags":["delev","gdb"],"title":"使用delve对go代码进行调试","uri":"/%E4%BD%BF%E7%94%A8delve%E5%AF%B9go%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95/"},{"categories":["golang"],"content":"一个简单的事件处理程序 demo目录结构 . ├── events │ └── event.go ├── go.mod └── main.go ","date":"2022-07-22","objectID":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/:0:0","tags":["event"],"title":"Golang实现一个简单的事件处理程序","uri":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"},{"categories":["golang"],"content":"event.go package events type EventHandler func(event Event) type Event interface { GetName() string GetData() interface{} } type EventBus struct { handlers map[string]EventHandler } func NewEventBus() *EventBus { return \u0026EventBus{ handlers: make(map[string]EventHandler), } } func (bus *EventBus) Register(name string, handler EventHandler) { bus.handlers[name] = handler } func (bus *EventBus) Dispatch(event Event) { if handler, ok := bus.handlers[event.GetName()]; ok { handler(event) } } func (bus *EventBus) DispatchAsync(event Event) { go bus.Dispatch(event) } var defaultEventBus *EventBus = nil func init() { if defaultEventBus == nil { defaultEventBus = NewEventBus() } } func DefaultEventBus() *EventBus { return defaultEventBus } ","date":"2022-07-22","objectID":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/:1:0","tags":["event"],"title":"Golang实现一个简单的事件处理程序","uri":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"},{"categories":["golang"],"content":"demo ","date":"2022-07-22","objectID":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/:2:0","tags":["event"],"title":"Golang实现一个简单的事件处理程序","uri":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"},{"categories":["golang"],"content":"login.go 一个ticker事件 const TickEventName = \"TickerEvent\" type TickerEvent struct { } func (e TickerEvent) GetName() string { return TickEventName } func (e TickerEvent) GetData() interface{} { return time.Now() } ","date":"2022-07-22","objectID":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/:2:1","tags":["event"],"title":"Golang实现一个简单的事件处理程序","uri":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"},{"categories":["golang"],"content":"main.go package main import ( \"fmt\" \"simpleEvent/events\" \"time\" ) const TickEventName = \"TickerEvent\" type TickerEvent struct { } func (e TickerEvent) GetName() string { return TickEventName } func (e TickerEvent) GetData() interface{} { return time.Now() } func makeEvents() { ticker := time.NewTicker(time.Second * 1) for true { \u003c-ticker.C //触发事件 events.DefaultEventBus().DispatchAsync(TickerEvent{}) } } func main() { go makeEvents() //监听事件 events.DefaultEventBus().Register(TickEventName, func(e events.Event) { fmt.Println(\"event received:\", e.GetData()) }) for true { time.Sleep(time.Second * 10) } } 输出: event received: 2022-08-08 11:22:48.61607 +0800 CST m=+1.000275696 event received: 2022-08-08 11:22:49.616192 +0800 CST m=+2.000391077 event received: 2022-08-08 11:22:50.616163 +0800 CST m=+3.000355464 event received: 2022-08-08 11:22:51.616159 +0800 CST m=+4.000344450 event received: 2022-08-08 11:22:52.616195 +0800 CST m=+5.000373565 ... ","date":"2022-07-22","objectID":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/:2:2","tags":["event"],"title":"Golang实现一个简单的事件处理程序","uri":"/golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/"},{"categories":["windows"],"content":"如何让MFC窗体程序弹出命令行窗口并打印日志输出 习惯了linux上运行程序时在terminal中查看打印的日志. 但在MFC窗口程序中却不行. 折腾了一下, 结果如下 ","date":"2022-07-13","objectID":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:0:0","tags":["vc++"],"title":"MFC窗体程序弹出命令行窗口显示日志输出","uri":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["windows"],"content":"弹出命令行窗口 在主程序的XXX::InitInstance()函数中添加 #ifdef _DEBUG if (!AllocConsole()) AfxMessageBox(\"Failed to create the console!\", MB_ICONEXCLAMATION); #endif 在对应的XXX::ExitInstance()中添加 #ifdef _DEBUG if (!FreeConsole()) AfxMessageBox(\"Could not free the console!\"); #endif 这样在DEBUG模式下启动程序时, 会弹出命令行窗口 ","date":"2022-07-13","objectID":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:1:0","tags":["vc++"],"title":"MFC窗体程序弹出命令行窗口显示日志输出","uri":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["windows"],"content":"打印日志(含文件名, 代码行号) #define LOG2CONSOLE(X) \\ { \\ std::string file = __FILE__; \\ size_t index; \\ for (index = file.size()-1; index \u003e 0; index--) { \\ if (file[index] == '\\\\') break; \\ } \\ std::string fileName = file.substr(index + 1); \\ std::stringstream ss; \\ ss \u003c\u003c X; \\ std::string s = ss.str(); \\ _cprintf(\"%s:%i %s\\n\", fileName.c_str(), __LINE__, s.c_str()); \\ } 1, 注意要使用宏, 而不是函数, 否则代码文件名和代码行始终是定义的位置 2, 宏换行的话, 除了最后一个大括号, 每一行后面都要接一个 \\ ","date":"2022-07-13","objectID":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:2:0","tags":["vc++"],"title":"MFC窗体程序弹出命令行窗口显示日志输出","uri":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["windows"],"content":"使用 LOG2CONSOLE(\"[Clicked] my button clicked. the xxx value is:\" \u003c\u003c something); ","date":"2022-07-13","objectID":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:3:0","tags":["vc++"],"title":"MFC窗体程序弹出命令行窗口显示日志输出","uri":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["windows"],"content":"使用printf 上面的宏中使用的是 _cprintf, 我发现在某些时候, 即便输出的是ascii字符, 也会出现乱码. 改成printf又打印不出来, 为了让printf能打印出来, 修改: #ifdef _DEBUG if (!AllocConsole()) AfxMessageBox(\"Failed to create the console!\", MB_ICONEXCLAMATION); #endif 为 #ifdef _DEBUG AllocConsole(); //freopen(\"CONIN$\", \"r\", stdin); freopen(\"CONOUT$\", \"w\", stdout); freopen(\"CONOUT$\", \"w\", stderr); #endif ","date":"2022-07-13","objectID":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/:4:0","tags":["vc++"],"title":"MFC窗体程序弹出命令行窗口显示日志输出","uri":"/mfc%E7%AA%97%E4%BD%93%E7%A8%8B%E5%BA%8F%E5%BC%B9%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%E6%98%BE%E7%A4%BA%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA/"},{"categories":["windows"],"content":"关于编译Windows MFC 项目遇到的Error : WINDOWS.H Already Included的解决方法 ","date":"2022-07-12","objectID":"/error--windows.h-already-included/:0:0","tags":["vc++"],"title":"Error : WINDOWS.H Already Included","uri":"/error--windows.h-already-included/"},{"categories":["windows"],"content":"现象 今天接到一个老旧的MFC项目, 安装windows虚拟机, VS2010 (真是老掉牙呀) , 最后编译时出现一堆如下报错: 1\u003e app.cpp 1\u003ec:\\program files (x86)\\microsoft visual studio 10.0\\vc\\atlmfc\\include\\afxv_w32.h(16): fatal error C1189: #error : WINDOWS.H already included. MFC apps must not #include \u003cwindows.h\u003e ","date":"2022-07-12","objectID":"/error--windows.h-already-included/:1:0","tags":["vc++"],"title":"Error : WINDOWS.H Already Included","uri":"/error--windows.h-already-included/"},{"categories":["windows"],"content":"解决方法 经过一番折腾, 直接说结论: #include “stdafx.h” 必须放在其他头文件之前 这涉及到一个很恶心的问题, 如果多个头文件层层include, 得耐心地慢慢调整顺序 ","date":"2022-07-12","objectID":"/error--windows.h-already-included/:2:0","tags":["vc++"],"title":"Error : WINDOWS.H Already Included","uri":"/error--windows.h-already-included/"},{"categories":["windows"],"content":"举例 比如 下面这个就会报错: //a.h #include \"b.h\" #include \"c.h\" //b.h #include \"xxx.h\" //c.h #include \"yyy.h\" #include \"stdafx.h\" 需要调整2处: 1, c.h 中 #include \"stdafx.h\" 需要放到 #include \"yyy.h\" 前面 2, a.h 中 #include \"c.h\" 需要放到 #include \"b.h\" 前面 最后这样: //a.h #include \"c.h\" #include \"b.h\" //b.h #include \"xxx.h\" //c.h #include \"stdafx.h\" #include \"yyy.h\" ","date":"2022-07-12","objectID":"/error--windows.h-already-included/:3:0","tags":["vc++"],"title":"Error : WINDOWS.H Already Included","uri":"/error--windows.h-already-included/"},{"categories":["aviation"],"content":"ARINC-429 定义了商用飞机航空电子系统之间数字数据传输的标准要求和协议。设备制造商遵循这些标准，从而实现航空电子设备的互换性. ","date":"2022-07-12","objectID":"/arinc429/:0:0","tags":["arinc429"],"title":"ARINC-429","uri":"/arinc429/"},{"categories":["aviation"],"content":"特点 ARINC 429 数据传输的独特之处在于其简单的单向总线通信数据流。虽然典型的数据总线在一组电线上的各个总线点之间提供多向数据传输。 ARINC-429 并非如此, 传说是为了系统可靠性。 ┌──────────┐ ┌─────────┐ ┌────────────┐ │RECEIVER_1│ │ ... │ │ RECEIVER_N │ └──────────┘ └─────────┘ └────────────┘ ┌─────────┐ ▲ ▲ ▲ │ SENDER │───────────┴────────────────┴──────────────────┘ └─────────┘ Sender可以支持最高20个Receiver 要想双向传输, 再添加一根线缆, Receiver变Sender Send和Receive通道在不同的端口上 以 32 位(bit)为一个数据字(WORD), 每个字代表一个工程单位，例如高度或气压 传输通道分为高速和低速两种, 前者100kb/s , 后者 12.5kb/s ","date":"2022-07-12","objectID":"/arinc429/:1:0","tags":["arinc429"],"title":"ARINC-429","uri":"/arinc429/"},{"categories":["aviation"],"content":"数据字结构 ┌──┬─────┬───────────────────────┬─────┬───────────────────────┐ │P │ SSM │ DATA │ SDI │ LABLE │ └──┴─────┴───────────────────────┴─────┴───────────────────────┘ ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐ │32│31│30│29│28│27│..│14│13│12│11│10│9 │8 │7 │6 │5 │4 │3 │2 │1 │ └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘ 数据以 32 位字通过 ARINC-429 总线发送，每个字代表一个工程单位，例如高度或气压。消息的不同部分如上图所示. LABEL: 8 位标签用于解释消息的其他字段——每种类型的设备都有一组由标签编号标识的标准参数，而与制造商无关。例如，任何航向参考系统的标签 372 将提供风向，任何空气数据计算机的标签 203 将提供气压高度 ongoing…. ","date":"2022-07-12","objectID":"/arinc429/:2:0","tags":["arinc429"],"title":"ARINC-429","uri":"/arinc429/"},{"categories":["BlockChain"],"content":"“如何达成共识\"是分布式系统的一个最基本的问题. 区块链作为一个分布式系统, 这也是最核心的问题. 共识算法很多, PoW、 BFT 、POS .. 以及的变体, 比如PBFT、 IBFT、Tendermint、DPoS、 HotStuff 等. 但作为区块链的鼻祖的BTC和元老的ETH都使用的PoW, ETH正在过度到PoS, 另外有一些区块链采用了PoS的一个变体DPoS.我们主要关注这几种. 今天先说说PoW ","date":"2022-07-08","objectID":"/pow/:0:0","tags":["pow","consensus"],"title":"PoW","uri":"/pow/"},{"categories":["BlockChain"],"content":"原理 PoW Proof of Work 工作量证明 在挖矿的时候通过作出\"一定的工作量\"来增加作恶成本. 其基本原理是通过一个简单但又费力的数学计算来体现工作量. 这样的数学计算有很多, 比如质因数分解, 计算hash等. ","date":"2022-07-08","objectID":"/pow/:1:0","tags":["pow","consensus"],"title":"PoW","uri":"/pow/"},{"categories":["BlockChain"],"content":"Hash 哈希函数用于为任意长的输入字符串创建固定长度的摘要,有各种系列的哈希函数，如MD、SHA1、SHA-2、SHA-3、RIPEMD和Whirlpool 特点: 哈希函数必须能够接受任何长度的输入文本，并输出一个固定长度的压缩信息. 哈希函数的计算速度非常快。如果消息太大，效率可能会下降，但该函数仍应足够快，以满足实际使用 哈希函数的输出必须的稳定的, 输入不变时输出也不会发生变化 哈希不能反向推导. 也就是说很难通过哈希值反向计算出原始值. 这个叫原像防御或者叫单向属性 不同的信息要得到不同的哈希值. 这叫抗碰撞性 实际上, 输入信息稍加改变, 输出的哈希值将会有很大的差异. 这叫 雪崩效应 我们一般使用的是 SHA-256 举例 OSX MP16 ~ ❯ echo \"this is a test\" | openssl dgst -sha256 91751cee0a1ab8414400238a761411daa29643ab4b8243e9a91649e25be53ada OSX MP16 ~ ❯ echo \"this is A test\" | openssl dgst -sha256 215ec5072f0ae6f05d9576d42c1a3fb5794aa51199cb44e7d087e679ff000d1 ","date":"2022-07-08","objectID":"/pow/:2:0","tags":["pow","consensus"],"title":"PoW","uri":"/pow/"},{"categories":["BlockChain"],"content":"Hash解密游戏 假设有这样一个游戏: 给定一个常量字符串str, 再加上一个可变数字num 得到 str+num, 通过不断变化num的值, 使得 hash(str+num)得到的哈希值满足一定的条件 就算成功. 假设我们需要满足的条件是: 哈希值以0000开头 func main() { str := \"this is a test string\" num := 0 for true { tempStr := str + strconv.Itoa(num) h := sha256.New() h.Write([]byte(tempStr)) sum := h.Sum(nil) s := hex.EncodeToString(sum) fmt.Println(\"try:\" + s) if s[0:4] == \"0000\" { fmt.Println(\"找到num: \", num) fmt.Println(\"找到hash: \", s) break } num++ } } 运行结果: try:2717e2d84df58353433bdef467f5f12766710aedc7114d409d04d6712b670edb try:a13b43128c8961d36d9f7aca7fd82018497d713e5305e86f1ba6c900e7870e61 try:5a968dcad3ab8564046abedff836a91242d77207b758f079865680b96e9e9b3a ... ... 找到num: 7521 找到hash: 0000e87f07402bc7592d63fc8876fc4685eb52649ceefa78915b33d7792be1f0 经过七千多次尝试, 找到了当num为7521时, 满足条件 ","date":"2022-07-08","objectID":"/pow/:3:0","tags":["pow","consensus"],"title":"PoW","uri":"/pow/"},{"categories":["BlockChain"],"content":"PoW 上面游戏中的给定字符串就算挖矿是的区块\"密封前\"的哈希值 ,包含前面的区块的哈希值和交易数据以及其它信息计算出来的哈希值, 但还没有成功挖矿,所以还没包含本区块的nonce等. 挖矿成功后, 会进行密封(Seal). 这里说的nonce也就是上面游戏中的num 游戏中还提到 一定的条件 , 在Pow中, 一定的条件就是找到的哈希值小于指定的 target , target是根据 难度 计算出来的. 所以我们可以得到这样一个简化版本的 PoW过程 package main import ( \"crypto/sha256\" \"fmt\" \"math/big\" \"strconv\" \"time\" ) func getTarget() *big.Int { //假设当前难度值 difficulty := 22341680 two256 := new(big.Int).Exp(big.NewInt(2), big.NewInt(256), big.NewInt(0)) return new(big.Int).Div(two256, big.NewInt(int64(difficulty))) } // getBlockHashBeforeSeal 获取区块在\"密封前\"的哈希值 func getBlockHashBeforeSeal() []byte { str := \"1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64\" //convert to bytes[] b := []byte(str) return b } func hash(s []byte) []byte { //使用sha256哈希函数 h := sha256.New() h.Write(s) sum := h.Sum(nil) return sum } func mine() uint64 { nonce := 0 target := getTarget() fmt.Println(\"target: \", target) powBuffer := new(big.Int) //旷工挖矿，需要进行暴力遍历 //通过不停地改变nonce以便让hash值变化，然后找到刚好满足一定条件的值 for true { var bytes = append(getBlockHashBeforeSeal(), strconv.Itoa(nonce)...) sum := hash(bytes) if powBuffer.SetBytes(sum).Cmp(target) \u003c 0 { fmt.Println(\"找到nonce: \", nonce) break } nonce++ } return uint64(nonce) } func verify(nonce uint64) bool { //对旷工挖矿得到的结果进行验证 //验证只需要进行一次计算 powBuffer := new(big.Int) target := getTarget() var bytes = append(getBlockHashBeforeSeal(), strconv.Itoa(int(nonce))...) sum := hash(bytes) return powBuffer.SetBytes(sum).Cmp(target) \u003c 0 } func main() { startTime := time.Now() nonce := mine() fmt.Println(\"计算耗时: \", time.Now().Sub(startTime)) ok := verify(nonce) fmt.Println(\"验证结果: \", ok) } ","date":"2022-07-08","objectID":"/pow/:4:0","tags":["pow","consensus"],"title":"PoW","uri":"/pow/"},{"categories":["BlockChain"],"content":"go-etherum go-etherum的PoW用到的算法名称叫 Ethash 其挖矿逻辑在 go-ethereum-1.10.20/consensus/ethash/sealer.go 中的 mine 方法 ","date":"2022-07-08","objectID":"/pow/:5:0","tags":["pow","consensus"],"title":"PoW","uri":"/pow/"},{"categories":["BlockChain"],"content":"对创世文件的介绍 在 https://yinhui1984.github.io/从零开始编写智能合约-手工打造/#编写创世文件中提到了genesis.json, 它是区块链的初始配置文件, 称为创世文件, 区块链中的第一个块(Block)需要用它来进行生成. 这个块称为创世块 ","date":"2022-07-06","objectID":"/genesis.json/:0:0","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Genesis struct 在go-ethereum中定义如下: //go-ethereum-1.10.20/params/config.go type Genesis struct { Config *params.ChainConfig `json:\"config\"` Nonce uint64 `json:\"nonce\"` Timestamp uint64 `json:\"timestamp\"` ExtraData []byte `json:\"extraData\"` GasLimit uint64 `json:\"gasLimit\" gencodec:\"required\"` Difficulty *big.Int `json:\"difficulty\" gencodec:\"required\"` Mixhash common.Hash `json:\"mixHash\"` Coinbase common.Address `json:\"coinbase\"` Alloc GenesisAlloc `json:\"alloc\" gencodec:\"required\"` // These fields are used for consensus tests. Please don't use them // in actual genesis blocks. Number uint64 `json:\"number\"` GasUsed uint64 `json:\"gasUsed\"` ParentHash common.Hash `json:\"parentHash\"` BaseFee *big.Int `json:\"baseFeePerGas\"` } 其中 Config字段: //go-ethereum-1.10.20/params/config.go // ChainConfig is the core config which determines the blockchain settings. // // ChainConfig is stored in the database on a per block basis. This means // that any network, identified by its genesis block, can have its own // set of configuration options. type ChainConfig struct { ChainID *big.Int `json:\"chainId\"` // chainId identifies the current chain and is used for replay protection HomesteadBlock *big.Int `json:\"homesteadBlock,omitempty\"` // Homestead switch block (nil = no fork, 0 = already homestead) DAOForkBlock *big.Int `json:\"daoForkBlock,omitempty\"` // TheDAO hard-fork switch block (nil = no fork) DAOForkSupport bool `json:\"daoForkSupport,omitempty\"` // Whether the nodes supports or opposes the DAO hard-fork // EIP150 implements the Gas price changes (https://github.com/ethereum/EIPs/issues/150) EIP150Block *big.Int `json:\"eip150Block,omitempty\"` // EIP150 HF block (nil = no fork) EIP150Hash common.Hash `json:\"eip150Hash,omitempty\"` // EIP150 HF hash (needed for header only clients as only gas pricing changed) EIP155Block *big.Int `json:\"eip155Block,omitempty\"` // EIP155 HF block EIP158Block *big.Int `json:\"eip158Block,omitempty\"` // EIP158 HF block ByzantiumBlock *big.Int `json:\"byzantiumBlock,omitempty\"` // Byzantium switch block (nil = no fork, 0 = already on byzantium) ConstantinopleBlock *big.Int `json:\"constantinopleBlock,omitempty\"` // Constantinople switch block (nil = no fork, 0 = already activated) PetersburgBlock *big.Int `json:\"petersburgBlock,omitempty\"` // Petersburg switch block (nil = same as Constantinople) IstanbulBlock *big.Int `json:\"istanbulBlock,omitempty\"` // Istanbul switch block (nil = no fork, 0 = already on istanbul) MuirGlacierBlock *big.Int `json:\"muirGlacierBlock,omitempty\"` // Eip-2384 (bomb delay) switch block (nil = no fork, 0 = already activated) BerlinBlock *big.Int `json:\"berlinBlock,omitempty\"` // Berlin switch block (nil = no fork, 0 = already on berlin) LondonBlock *big.Int `json:\"londonBlock,omitempty\"` // London switch block (nil = no fork, 0 = already on london) ArrowGlacierBlock *big.Int `json:\"arrowGlacierBlock,omitempty\"` // Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) GrayGlacierBlock *big.Int `json:\"grayGlacierBlock,omitempty\"` // Eip-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) MergeNetsplitBlock *big.Int `json:\"mergeNetsplitBlock,omitempty\"` // Virtual fork after The Merge to use as a network splitter // TerminalTotalDifficulty is the amount of total difficulty reached by // the network that triggers the consensus upgrade. TerminalTotalDifficulty *big.Int `json:\"terminalTotalDifficulty,omitempty\"` // Various consensus engines Ethash *EthashConfig `json:\"ethash,omitempty\"` Clique *CliqueConfig `json:\"clique,omitempty\"` } ","date":"2022-07-06","objectID":"/genesis.json/:1:0","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"ChainID 区块链ID, 每一个对外公开的链ID是唯一的, 这个ID可以在https://chainlist.org上进行查询和申请 之所以加这样一个ChainID是为了防止\"重放攻击\":是在一个区块链上进行交易，并恶意或欺诈性地在另一个区块链上重复该交易. 参考这里EIP155 或这里 EIP : Ethereum Improvement Proposals 以太坊改进提案 ","date":"2022-07-06","objectID":"/genesis.json/:1:1","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"HomesteadBlock HomesteadBlock 以及后面的各种xxxBlock都是指的是ETH的硬分叉高度. 关于分叉,参考这里 这里可以看到主网的分叉历史 : https://ethereum.org/en/history/ 对于新建测试网而言, 应该设置为0 , 表示你没有分叉 ","date":"2022-07-06","objectID":"/genesis.json/:1:2","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"TerminalTotalDifficulty TTD, 终端总难度, 网络达到的总难度 最近提到TTD的一个新闻是ETH将在Ropsten测试网的TTD达到一个值时触发链上合并, 以将其POW(工作量证明)升级为POS(权益证明, proof-of-stake) ","date":"2022-07-06","objectID":"/genesis.json/:1:3","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Ethash Ethash是Ethereum使用的POW算法。这是目前主网使用的算法. 具体参考 https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/mining-algorithms/ 和 https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/mining-algorithms/ethash/ 以及 https://ethereum.stackexchange.com/questions/14/what-proof-of-work-function-does-ethereum-use ","date":"2022-07-06","objectID":"/genesis.json/:1:4","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Clique Clique [/kliːk/] 是测试网使用的权益证明POS 算法, 主网一直在努力尽快切换到POS 具体参考这里 https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/ ","date":"2022-07-06","objectID":"/genesis.json/:1:5","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Nonce 和 Mixhash Nonce是一个64位的哈希值, mixhash字段包含一个256位的哈希值，一旦与nonce结合，就可以用来证明为了创建这个区块，已经花费了足够的算力. 后面搞篇博客专门来讲工作量证明 ","date":"2022-07-06","objectID":"/genesis.json/:1:6","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Timestamp Unix时间戳 。利用块与块之间的时间戳来调整难度, 以保证出块时间的稳定性. 最后两个块之间的较小周期导致难度级别增加，因此需要额外的计算来找到下一个有效块。如果周期太大，则难度和下一个区块的预期时间会降低。时间戳还允许验证链中块的顺序. ","date":"2022-07-06","objectID":"/genesis.json/:1:7","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"ExtraData 额外数据. 想写入区块链的任意数据, 但只有32 个字节 ","date":"2022-07-06","objectID":"/genesis.json/:1:8","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"GasLimit 每个区块的Gas支出限额 ","date":"2022-07-06","objectID":"/genesis.json/:1:9","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Difficulty 难度. 它代表了证明PoW所需的哈希值的难度等级。 它定义了挖矿目标，可以根据前一个区块的难度级别和时间戳来计算。难度越高，矿工为了发现有效区块必须执行的统计计算就越多。该值用于控制区块链的出块时间，使出块频率保持在目标范围内 ","date":"2022-07-06","objectID":"/genesis.json/:1:10","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Coinbase 这是一个160位的地址，挖矿成功后，挖矿奖励就会发送到这里。 有些地方称之为 Etherbase, 比如 miner.setEtherbase(personal.listAccounts[0]) ","date":"2022-07-06","objectID":"/genesis.json/:1:11","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"alloc 这个参数包含预先分配的钱包和余额列表. 初始化区块链的时候, 这个参数必须被填写, 否则没钱支付挖矿费用, 产生不了块. ","date":"2022-07-06","objectID":"/genesis.json/:1:12","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"Number, GasUsed, ParentHash, BaseFee // These fields are used for consensus tests. Please don't use them // in actual genesis blocks. ","date":"2022-07-06","objectID":"/genesis.json/:1:13","tags":["genesis.json"],"title":"genesis.json","uri":"/genesis.json/"},{"categories":["BlockChain"],"content":"介绍了调用智能合约中\"读方法\"与\"写方法\"的区别 ","date":"2022-07-04","objectID":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/:0:0","tags":["web3.py","web3.js"],"title":"对智能合约的读方法和写方法的调用","uri":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"},{"categories":["BlockChain"],"content":"方法(函数)的分类 智能合约中的方法可以粗暴的分为两类: 不会改变虚拟机状态的方法 会改变虚拟机状态的方法 假设我们将他们称为\"读方法\"和\"写方法\", 那么读方法而言, 其是不会创建交易和花费GAS的, 是免费的. 对于写方法而言, 需要收取’手续费’进行挖矿的. 关键字 描述 改变虚拟机状态? pure 不读数据, 也不写数据 NO view 读数据, 但不写数据 NO payable 支付以太, 肯定写数据 YES 未明确指示的 其它可能写数据的 YES ","date":"2022-07-04","objectID":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/:1:0","tags":["web3.py","web3.js"],"title":"对智能合约的读方法和写方法的调用","uri":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"},{"categories":["BlockChain"],"content":"Web3.js的 call() 与Send() 对于上面两类方法, Web3.js中分别对应Call方法和Send方法来进行调用 创建交易 改变虚拟机状态 Call() NO NO Send() YES YES 实际上从语法层面上而言, 无论是读方法还是写方法, 都可以调用 call , 但对于写方法, 调用call虚拟机状态并不会改变, 并且不会报错. ","date":"2022-07-04","objectID":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/:2:0","tags":["web3.py","web3.js"],"title":"对智能合约的读方法和写方法的调用","uri":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"},{"categories":["BlockChain"],"content":"举例 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract temp { int private counter; function add() public { counter ++; } function get() public view returns(int){ return counter; } } 调用代码 const base = require('./base'); const c = base.initContract('temp'); async function test(){ await c.methods.get().call().then(x=\u003e{ console.log(\"current value:\", x); }) await c.methods.add().call() await c.methods.get().call().then(x=\u003e{ console.log(\"after call add(): current value:\", x); }) let accounts = await base.web3Instance.eth.getAccounts(); await c.methods.add().send({from: accounts[0], gas: 3000000}) await c.methods.get().call().then(x=\u003e{ console.log(\"after send add(): current value:\", x); }) } test() 输出 current value: 0 after call add(): current value: 0 after send add(): current value: 1 可以看到使用 call 调用 add()后 值并没有变, 而用 send调用add()后, 值被累加1 ","date":"2022-07-04","objectID":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/:3:0","tags":["web3.py","web3.js"],"title":"对智能合约的读方法和写方法的调用","uri":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"},{"categories":["BlockChain"],"content":"web3.py web3.py 中对应的是 call()和transact() ","date":"2022-07-04","objectID":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/:4:0","tags":["web3.py","web3.js"],"title":"对智能合约的读方法和写方法的调用","uri":"/%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/"},{"categories":["BlockChain"],"content":"让自己使用geth运行的区块链像Ganche一样可以AUTOMINING 在做智能合约开发过程中, 如果使用Ganche的话, 可以发现其有一个非常爽的功能:AUTOMINING 自动挖矿 或按需挖矿, 也就是说不需要挖矿的时候就别挖, 否则非常耗电脑资源. 如果我们是自己使用geth运行的测试链, 则没有这个功能, 需要手动attach到控制台进行miner.start()和miner.stop, 非常不方便. ","date":"2022-07-03","objectID":"/%E4%BD%BF%E7%94%A8web3.py%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8C%89%E9%9C%80%E6%8C%96%E7%9F%BF/:0:0","tags":["web3.py","python"],"title":"使用web3.py实现区块链按需挖矿","uri":"/%E4%BD%BF%E7%94%A8web3.py%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8C%89%E9%9C%80%E6%8C%96%E7%9F%BF/"},{"categories":["BlockChain"],"content":"Web3.js 如果使用Web3.js,貌似没有看到miner控制的API, 不过Gitub上有一个扩展, 可以实现 https://github.com/DecentricCorp/web3admin 利用这个扩展可以实现我们想要的功能. ","date":"2022-07-03","objectID":"/%E4%BD%BF%E7%94%A8web3.py%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8C%89%E9%9C%80%E6%8C%96%E7%9F%BF/:1:0","tags":["web3.py","python"],"title":"使用web3.py实现区块链按需挖矿","uri":"/%E4%BD%BF%E7%94%A8web3.py%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8C%89%E9%9C%80%E6%8C%96%E7%9F%BF/"},{"categories":["BlockChain"],"content":"Web3.py Web3.py自带miner控制的API, 这就比较方便了. 每隔几秒轮询一下是否有pending的block, 如果有则挖, 否则停止挖矿 脚本如下 #!/usr/bin/env python3 import os import time from web3 import Web3 # pip3 install web3 # 按需挖矿 #使用前请先修改provide w3 = Web3(Web3.IPCProvider('../mychain/data/geth.ipc')) num_threads = os.cpu_count() def main(): # kill this script os.system(\"killall -9 python \u003e /dev/null 2\u003e\u00261\") print('Connected to Ethereum client: %s' % w3.clientVersion) print(\"启动自动挖矿...\") while True: time.sleep(3) if w3.eth.getBlock('pending').transactions: print( time.strftime(\"%H:%M:%S\", time.localtime()) + \":Mining for pending transactions: %s\" % w3.eth.getBlock( 'pending').transactions) w3.geth.miner.start(num_threads) else: print(time.strftime(\"%H:%M:%S\", time.localtime()) + ':No pending transactions, sleeping...', end='\\r') w3.geth.miner.stop() if __name__ == \"__main__\": try: main() except KeyboardInterrupt: print(\"\\n\\nCtrl+C, bye!\") w3.geth.miner.stop() exit(0) except Exception as e: print(\"发生错误: %s\" % e) exit(0) 运行时的样子 Connected to Ethereum client: Geth/v1.10.16-stable/darwin-amd64/go1.17.6 启动自动挖矿... 13:24:42:Mining for pending transactions: [HexBytes('0x0cecdc430a73adc915d9944798e71735a48940b90e38965a3e4a5c8db6b48cb5')] 13:24:57:No pending transactions, sleeping... ","date":"2022-07-03","objectID":"/%E4%BD%BF%E7%94%A8web3.py%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8C%89%E9%9C%80%E6%8C%96%E7%9F%BF/:2:0","tags":["web3.py","python"],"title":"使用web3.py实现区块链按需挖矿","uri":"/%E4%BD%BF%E7%94%A8web3.py%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8C%89%E9%9C%80%E6%8C%96%E7%9F%BF/"},{"categories":["BlockChain"],"content":"前面在 从零开始编写智能合约-使用traffle套件 中 使用 truffle套件从零开始搭建环境, 编写、部署、测试和调用智能合约, 这次我们只使用一些命令行工具来进行\"手工打造\" 配套代码: https://github.com/yinhui1984/stepByStepSmartContract ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:0:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"创建测试链 还是以ETH为例, 使用 Go Ethereum https://geth.ethereum.org 来创建 使用POW共识算法的一个简单私有链. ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"安装geth 官方教程 https://geth.ethereum.org/docs/install-and-build/installing-geth 或者自己下载安装包进行安装 https://geth.ethereum.org/downloads/ 安装完成后, 运行一下version表示成功 OSX MP16 ~/Downloads/privateNetwork ❯ geth version Geth Version: 1.10.16-stable Architecture: amd64 Go Version: go1.17.6 Operating System: darwin GOPATH= GOROOT=go ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:1","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"创建一个账户 下面的创世文件中的coinbase会用到这个账户, 用来接收挖矿的收入 为方便起见, 将账户密码写到password.txt , 当然这是不安全的行为. echo 123456 \u003e password.txt 新建账户: geth --datadir ./data/ account new --password ./password.txt 其中的datadir是数据存储目录, 后面的数据文件都将存到这个目录中 OSX MP16 ~/Downloads/privateNetwork ❯ geth --datadir ./data/ account new --password ./password.txt INFO [07-01|10:10:34.007] Maximum peer count ETH=50 LES=0 total=50 Your new key was generated Public address of the key: 0x79dF0D3c23f22370881dC92aF524A1D5E52e3552 Path of the secret key file: data/keystore/UTC--2022-07-01T02-10-34.008109000Z--79df0d3c23f22370881dc92af524a1d5e52e3552 - You can share your public address with anyone. Others need it to interact with you. - You must NEVER share the secret key with anyone! The key controls access to your funds! - You must BACKUP your key file! Without the key, it's impossible to access account funds! - You must REMEMBER your password! Without the password, it's impossible to decrypt the key! 打印内容中的 0x79dF0D3c23f22370881dC92aF524A1D5E52e3552是公钥, 也是我们的账户地址 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:2","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"找一个网络ID chainId或者network ID 用于隔离以太坊对等网络。只有当两个对等点使用相同的创世块和网络 ID 时，区块链节点之间才会发生连接。使用 –networkid 命令行选项设置 geth 使用的网络 ID。 以太网主网 ID 为 1。如果您提供与主网不同的自定义网络 ID，您的节点将不会连接到其他节点并形成专用网络。如果您打算在 Internet 上连接到您的私有链，最好选择一个尚未使用的网络 ID。您可以在 https://chainid.network 找到由社区运行的以太坊网络注册表。 这里我们只是在本地运行, 随便使用一个ID就可以了, 比如1235 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:3","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"编写\"创世文件\" 一个新的区块链在生成第一个区块, 也就是创世块的时候, 需要从创世文件来进行生成 touch genesis.json { \"nonce\": \"0x0000000000000042\", \"timestamp\": \"0x00\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"extraData\": \"0x00\", \"gasLimit\": \"0x8000000\", \"difficulty\": \"0x0400\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x79dF0D3c23f22370881dC92aF524A1D5E52e3552\", \"alloc\": { \"0x79dF0D3c23f22370881dC92aF524A1D5E52e3552\": { \"balance\": \"1000000000000000000000\" } }, \"config\": { \"chainId\": 1235, \"homesteadBlock\": 0, \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"eip150Block\": 0, \"eip155Block\": 0, \"eip158Block\": 0 } } 关于创世文件中的各个字段的含义, 后面会有一篇专门的博客来讲 注意: 将coinbase 以及 alloc中的地址修改为上面创建账户时你所得到的地址 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:4","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"初始化区块链 geth --datadir ./data init ./genesis.json 输出 INFO [07-01|10:50:50.915] Maximum peer count ETH=50 LES=0 total=50 INFO [07-01|10:50:50.919] Set global gas cap cap=50,000,000 INFO [07-01|10:50:50.919] Allocated cache and file handles database=/Users/zhouyinhui/Downloads/privateNetwork/data/geth/chaindata cache=16.00MiB handles=16 INFO [07-01|10:50:51.007] Writing custom genesis block INFO [07-01|10:50:51.010] Persisted trie from memory database nodes=0 size=0.00B time=\"21.005µs\" gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [07-01|10:50:51.011] Successfully wrote genesis state database=chaindata hash=0ca0fb..b61b69 INFO [07-01|10:50:51.011] Allocated cache and file handles database=/Users/zhouyinhui/Downloads/privateNetwork/data/geth/lightchaindata cache=16.00MiB handles=16 INFO [07-01|10:50:51.090] Writing custom genesis block INFO [07-01|10:50:51.090] Persisted trie from memory database nodes=0 size=0.00B time=\"2.71µs\" gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00B INFO [07-01|10:50:51.091] Successfully wrote genesis state database=lightchaindata hash=0ca0fb..b61b69 OSX MP16 ~/Downloads/privateNetwork ❯ 生成的文件在 ./data/geth下 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:1:5","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"运行区块链 geth --datadir ./data/ --networkid 1235 --port 8545 --http --http.api 'admin,eth,miner,net,txpool,personal,web3' --mine --allow-insecure-unlock --unlock '0x79dF0D3c23f22370881dC92aF524A1D5E52e3552' --password password.txt --datadir 数据文件目录 --networkid 网络ID --port RPC端口 --http 启用http-rpc服务 --http.api提供那些API --mine 启用挖矿 --allow-insecure-unlock 当账户相关的RPC被http暴露时，允许不安全的账户解锁 --unlock 解锁账户 (多个账户用逗号分割) --password 解锁账户用到的密码文件 成功运行后, 会看到很多打印信息, 其中值得注意的是下面这两行, 一个是ipc, 一个是http server, 我们会使用他们来和我们的区块链进行通讯 INFO [07-01|11:08:58.245] IPC endpoint opened url=/Users/zhouyinhui/Downloads/privateNetwork/data/geth.ipc INFO [07-01|11:08:58.245] HTTP server started endpoint=127.0.0.1:8545 prefix= cors= vhosts=localhost 另外一条是 我们作为区块链中的对等节点PEER NODE时的信息, 这里我们还用不到 Started P2P networking self=enode://de2537c5f309be45bcb2d011cd172138db40295f74a288b07e03635e2194e7c2987cf97c9d295dc502053d9f7adda11052597c7f1bc5a5ec3d8182777138a0f1@127.0.0.1:8545 请保持区块链在后台运行, 后面的代码都需要用到 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:2:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"与测试链进行交互 attach到测试链, 就可以启动一个js console, 和truffle console功能一样 方式1, 通过IPC进行attach geth attach /Users/zhouyinhui/Downloads/privateNetwork/data/geth.ipc OSX MP16 ~/blockchain/private_net/tempchain ❯ geth attach /Users/zhouyinhui/Downloads/privateNetwork/data/geth.ipc Welcome to the Geth JavaScript console! .... To exit, press ctrl-d or type exit \u003e eth.chainId() \"0x4d3\" \u003e \"0x4d3\" 也就是 我们的 1235 其中 *.ipc 可以使用相对路径 方式2, 通过http服务进行attach geth attach http://127.0.0.1:8545 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:3:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"一键生成测试链 上面那些繁琐的步骤可以搞成一个脚本, 一键生成, 这样来得更方便 脚本在这里: https://github.com/yinhui1984/stepByStepSmartContract/blob/main/autogen/autoGenChain.py (直接将代码贴到这里会导致GitHub Pages failed to build your site 😂) ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:4:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"编写智能合约 我们还是使用 上篇博客中的智能合约 mkdir ./contracts cd ./contracts touch Calculator.sol // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Calculator { function add(int a, int b) public pure returns (int) { return a + b; } function subtract(int a, int b) public pure returns (int) { return a - b; } } ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:5:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"编译智能合约 如果你的电脑上没有solc, 请事先安装, 它是solidity的编译器, 官方教程: https://docs.soliditylang.org/en/v0.8.15/installing-solidity.html#installing-solidity 编译: solc --bin --abi -o ./build ./Calculator.sol --bin 生成16进制文件 --abi生成abi文件 -o输出目录 可以写一个Makefile来干这个事情: all: solc --bin --abi --overwrite -o ./build ./Calculator.sol clean: rm -rf ./build/* OSX MP16 ~/Downloads/privateNetwork/contracts ❯ tree . ├── Calculator.sol ├── Makefile └── build ├── Calculator.abi └── Calculator.bin ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:6:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"部署智能合约 新建一个node.js 项目deploy mkdir -p deploy/ cd deploy/ npm init touch index.js 安装web3.js npm install web3 在index.js中加入如下代码: const fs = require('fs'); const Web3 = require('web3'); const web3 = new Web3('http://127.0.0.1:8545'); const bytecode = fs.readFileSync('../build/Calculator.bin').toString(); const abi = JSON.parse(fs.readFileSync('../build/Calculator.abi').toString()); (async function () { const accounts = await web3.eth.getAccounts(); const calculator = new web3.eth.Contract(abi); calculator.deploy({ data: bytecode }).send({ from: accounts[0], }).then((deployment) =\u003e { console.log('Contract was deployed at the following address:'); console.log(deployment.options.address); }).catch((err) =\u003e { console.error(err); }); })(); 注意, 上面的部署代码没有使用账户的私钥, 是因为在前面的步骤中, 账户已经解锁了 在部署之前需要先启动挖矿 OSX MP16 ~/Downloads/pri/mychain ❯ ./attach.sh ... \u003e miner.start() null \u003e eth.blockNumber 26 部署: OSX MP16 ~/Downloads/pri/c/d/deploy_js ❯ node ./index.js Contract was deployed at the following address: 0x1F55d61D5Aa8eC92FD1Da0f19FaC9D552A29DBBF 部署成功, 停掉挖矿, 否则电脑巨烫… \u003e miner.stop() null ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:7:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"调用智能合约 调用智能合约就和 从零开始编写智能合约-使用truffle套件中的一样了, 可以跳转到那里进行参考 ","date":"2022-07-01","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/:8:0","tags":["solidity","ethereum","go-ethereum","python"],"title":"从零开始编写智能合约-手工打造","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0/"},{"categories":["BlockChain"],"content":"这篇文章将带你使用traffle套件从零开始搭建环境, 编写、部署、测试和调用智能合约。 配套代码在 https://github.com/yinhui1984/HelloTruffle ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:0:0","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"使用traffle套件 ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:0","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"1. 安装node.js https://nodejs.org/en/ 安装完成后, 查看是否版本以确保成功 npm -v node -v ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:1","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"2. 安装truffle和Ganache truffle是一套智能合约的开发测试环境 Ganache用于创建测试链(可以创建ETH FILECOIN等测试链), 用来跑自己创建的合约. https://trufflesuite.com 使用npm安装truffle npm install -g truffle 安装完成后, 查看版本以确保成功 truffle version 如果遇到permission denied: truffle 找到truffle文件 ll /usr/local/bin/truffle 可以看到其软连接到cli.bundled.js Permissions Size User Date Modified Name lrwxr-xr-x 48 zhouyinhui 29 Jun 14:06  /usr/local/bin/truffle -\u003e ../lib/node_modules/truffle/build/cli.bundled.js 给这个js加上执行权限即可 chmod +x /usr/local/lib/node_modules/truffle/build/cli.bundled.js 安装Ganache 到这里直接下载即可 https://trufflesuite.com/ganache/ ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:2","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"3. 使用truffle新建项目 新建一个目录, 比如~/Downloads/truffleTest 到这个目录下 OSX MP16 ~/Downloads/truffleTest ❯ truffle init Starting init... ================ \u003e Copying project files to /Users/zhouyinhui/Downloads/truffleTest Init successful, sweet! Try our scaffold commands to get started: $ truffle create contract YourContractName # scaffold a contract $ truffle create test YourTestName # scaffold a test http://trufflesuite.com/docs 其新建了这些文件 OSX MP16 ~/Downloads/truffleTest ❯ tree . ├── contracts │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js contracts文件夹存放合约的地方, 在其中新建一个solidity源码文件, 比如Calculator.sol touch ./contracts/Calculator.sol 在Calculator.sol中添加如下代码来做个加减法 // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Calculator { function add(int a, int b) public pure returns (int) { return a + b; } function subtract(int a, int b) public pure returns (int) { return a - b; } } 其中的pure表示改函数既不读也不写状态机变量 https://hashnode.com/post/pure-vs-view-in-solidity-cl04tbzlh07kaudnv1ial1gio 复制上面代码时注意 pragma solidity ^0.8.0;这一行和 trffle-config.js中的下面的配置相匹配 // Configure your compilers compilers: { solc: { version: \"0.8.15\", //.... }, } pragma solidity ^0.8.0 表示编译器使用0.8到0.9版本之间的(不包含0.9), 那么trffle-config.js中配置的编译器版本要在这个范围内 ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:3","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"4.编译 truffle compile OSX MP16 ~/Downloads/truffleTest ❯ truffle compile Compiling your contracts... =========================== \u003e Compiling ./contracts/Calculator.sol \u003e Artifacts written to /Users/zhouyinhui/Downloads/truffleTest/build/contracts \u003e Compiled successfully using: - solc: 0.8.15+commit.e14f2714.Emscripten.clang 编译完成后, 会将结果放到build目录下: 我们这里关心的是Calculator.json OSX MP16 ~/Downloads/truffleTest ❯ tree . ├── build │ └── contracts │ ├── Calculator.json │ └── Migrations.json ├── contracts │ ├── Calculator.sol │ └── Migrations.sol ├── migrations │ └── 1_initial_migration.js ├── test └── truffle-config.js 5 directories, 6 files ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:4","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"5.部署到测试链 启动测试链 启动 ganache App, 点击QUICKSTART 其就自动创建了ETH测试链, 查看窗口上半部分显示的的RPC server信息, 比如 HTTP://127.0.0.1:8545 修改 truffle-config.js中的部署配置, 使其与上面的RPC server向匹配 networks: { //... development: { host: \"127.0.0.1\", // Localhost (default: none) port: 8545, // Standard Ethereum port (default: none) network_id: \"*\", // Any network (default: none) }, Note 请保持ganache在后台运行, 后面的代码都需要访问测试链 添加部署代码 touch migrations/2_deploy_contracts.js 在2_deploy_contracts.js中加入如下代码 var Calculator = artifacts.require(\"./Calculator.sol\"); module.exports = function(deployer) { deployer.deploy(Calculator); } 部署合约 运行 truffle migrate 命令进行部署 OSX MP16 ~/Downloads/truffleTest ❯ truffle migrate Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. Starting migrations... ====================== \u003e Network name: 'development' \u003e Network id: 5777 \u003e Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- \u003e transaction hash: 0xc4b0bf65cbac8d1cf68b72fc6408bd443c18e6bf3e44c5985dede50b191a80d1 \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0xe2fd5fA1303B9791417EF637AABd50aE9DB9Af44 \u003e block number: 1 \u003e block timestamp: 1656490514 \u003e account: 0xe149d5f732685669C9E494B233fDB4312d19b5cF \u003e balance: 99.99502292 \u003e gas used: 248854 (0x3cc16) \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00497708 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00497708 ETH 2_deploy_contracts.js ===================== Deploying 'Calculator' ---------------------- \u003e transaction hash: 0xc8cce4b870d187dadf38353e6ef71aabd0751375a2f2b8c763ed4a35d8067a0c \u003e Blocks: 0 Seconds: 0 \u003e contract address: 0x6B62e4E253823FBC65E0B93d63ee149350158a18 \u003e block number: 3 \u003e block timestamp: 1656490515 \u003e account: 0xe149d5f732685669C9E494B233fDB4312d19b5cF \u003e balance: 99.98984578 \u003e gas used: 216344 (0x34d18) \u003e gas price: 20 gwei \u003e value sent: 0 ETH \u003e total cost: 0.00432688 ETH \u003e Saving migration to chain. \u003e Saving artifacts ------------------------------------- \u003e Total cost: 0.00432688 ETH Summary ======= \u003e Total deployments: 2 \u003e Final cost: 0.00930396 ETH ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:5","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"6. 测试合约 使用truffle console 手动调用 运行 truffle console 打开控制台 truffle(development)\u003e let cal = await Calculator.deployed() truffle(development)\u003e cal.add(1,2) BN { negative: 0, words: [ 3, \u003c1 empty item\u003e ], length: 1, red: null } truffle(development)\u003e cal.subtract(10, 2) BN { negative: 0, words: [ 8, \u003c1 empty item\u003e ], length: 1, red: null } 在控制台中可以使用TAB按键来提示成员变量或函数 使用js编写单元测试 touch test/testCalculator.test.js //testCalculator.test.js //开发框架导入合约 const Calculator = artifacts.require(\"Calculator\"); //接下来，我们定义用于测试的合约，然后将账户作为包含所有地址的参数传递。 contract(\"Calculator\", accounts =\u003e { //it包含对我们要运行的测试的简短描述， // 它是一个包含所有测试相关脚本的异步函数 it(\"should add two numbers\", async () =\u003e { //cal: 定义存储已部署合约的实例。 const cal = await Calculator.deployed(); const result = await cal.add(4, 2); assert.equal(result.toNumber(), 6); }).timeout(10000); it(\"should subtract two numbers\", async () =\u003e { const cal = await Calculator.deployed(); const result = await cal.subtract(3, 2); assert.equal(result.toNumber(), 1); }).timeout(10000); }); 运行 truffle test 跑测试 OSX MP16 ~/Downloads/truffleTest ❯ truffle test Using network 'development'. Compiling your contracts... =========================== \u003e Everything is up to date, there is nothing to compile. Contract: Calculator ✔ should add two numbers ✔ should subtract two numbers (48ms) 2 passing (126ms) ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:6","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"7. demoApp调用合约 使用web3.js 我们使用web3.js 创建一个app来实际使用我们的合约 初始化一个node.js app mkdir -p ./demo/jsApp cd ./demo/jsApp/ npm init 然后一路默认回车 touch index.js 安装web3.js npm install web3 在index.js中加入如下代码 const Web3 = require('web3'); //注意，这里有个坑， 有时候http://localhost:8545 用localhost可以，有时候连接不上 //最好用127.0.0.1 const web3 = new Web3(new Web3.providers.HttpProvider(\"http://127.0.0.1:8545\")); //web3.eth.getAccounts().then(console.log) //modify the following line to your own contract address let contractAddress = \"0x6B62e4E253823FBC65E0B93d63ee149350158a18\"; //copy abi from ./build/contracts/Calculator.json let abi = [ { \"inputs\": [ { \"internalType\": \"int256\", \"name\": \"a\", \"type\": \"int256\" }, { \"internalType\": \"int256\", \"name\": \"b\", \"type\": \"int256\" } ], \"name\": \"add\", \"outputs\": [ { \"internalType\": \"int256\", \"name\": \"\", \"type\": \"int256\" } ], \"stateMutability\": \"pure\", \"type\": \"function\", \"constant\": true }, { \"inputs\": [ { \"internalType\": \"int256\", \"name\": \"a\", \"type\": \"int256\" }, { \"internalType\": \"int256\", \"name\": \"b\", \"type\": \"int256\" } ], \"name\": \"subtract\", \"outputs\": [ { \"internalType\": \"int256\", \"name\": \"\", \"type\": \"int256\" } ], \"stateMutability\": \"pure\", \"type\": \"function\", \"constant\": true } ] let contract = new web3.eth.Contract(abi,contractAddress); contract.methods.add(4,2).call().then(console.log); contract.methods.subtract(3,2).call().then(console.log); 其中的 contractAddress是我们部署的Caculator合约地址 如何找到合约地址? 方式1, 在上面的truffle migrate进行合约部署时,会打印 方式2, 在Ganache软件界面的Transactions中找, 貌似不方便 方式3, 在Ganache软件界面 : Settings -\u003e Workspace 中点击ADD Project 添加 truffle-config.js文件关联项目, 然后点击RESTART重新回到主界面的CONTRACTS就可以看到了 方式4, 运行truffle console truffle(development)\u003e Calculator.address '0x6B62e4E253823FBC65E0B93d63ee149350158a18' 其中的abi是合约对应的abi 如何找到abi? 方式1, solc --abi ./contracts/Calculator.sol 方式2, 到./build/contracts/Calculator.json中, 找到\"abi\"对应的值 不要使用truffle console中的Calculator.abi 运行app OSX MP16 ~/Downloads/truffleTest/demo/jsApp ❯ node index.js 6 1 使用golang mkdir -p ./demo/goApp cd ./demo/goApp touch main.go go mod init goApp 需要使用到 \"github.com/ethereum/go-ethereum/ethclient\"这个包 go get \"github.com/ethereum/go-ethereum/ethclient\" 这个包如果要调用合约, 则需要一些额外的操作 额外的操作: 利用 abigen 从solidity源文件生成golang代码 OSX MP16 ~/Downloads/truffleTest/demo/goApp ❯ mkdir contracts abigen --pkg contracts --sol ../../contracts/Calculator.sol --out ./contracts/calculatorContract.go –pkg contracts : 指定生成的代码的 package name –sol ../../contracts/Calculator.sol : 指定合约代码位置 –out ./contracts/calculatorContract.go: 指定生成的代码位置 生成完成后, goApp的目录结构如下: tree ~/Downloads/truffleTest/demo/goApp /Users/zhouyinhui/Downloads/truffleTest/demo/goApp ├── contracts │ └── calculatorContract.go ├── go.mod ├── go.sum └── main.go 生成后的calculatorContract.go中import包,可能并不在go.mod中, 所以运行一次 go mod tidy以避免编译时找不到包 main.go中代码如下: package main import ( \"fmt\" \"github.com/ethereum/go-ethereum/accounts/abi/bind\" \"github.com/ethereum/go-ethereum/common\" \"github.com/ethereum/go-ethereum/ethclient\" \"goApp/contracts\" \"math/big\" ) //https://goethereumbook.org/client-setup/ func main() { client, err := ethclient.Dial(\"http://localhost:8545\") if err != nil { fmt.Println(\"could not connect to local node, err:\", err) return } contractAddress := common.HexToAddress(\"0x6B62e4E253823FBC65E0B93d63ee149350158a18\") calculator, err := contracts.NewCalculator(contractAddress, client) if err != nil { fmt.Println(\"could not instantiate contract, err:\", err) return } callOpts := bind.CallOpts{ Context: nil, Pending: false, } a := big.NewInt(1) b := big.NewInt(2) result, err := calculator.Add(\u0026callOpts, a, b) if err != nil { fmt.Println(\"could not call contract, err:\", err) return } fmt.Println(\"add result:\", result) result, err = calculator.Subtract(\u0026callOpts, a, b) if err != nil { fmt.Println(\"could not call contract, err:\", err) return } fmt.Println(\"subtract result:\", result) } 运行 OSX MP16 ~/Downloads/truffleTest/demo/goApp ❯ go run . add result: 3 subtract result: -1 ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:1:7","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["BlockChain"],"content":"手工撸 这里: https://yinhui1984.github.io/从零开始编写智能合约-手工打造/ ","date":"2022-06-29","objectID":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/:2:0","tags":["solidity","truffle","ganache","ethereum","go-ethereum"],"title":"从零开始编写智能合约-使用traffle套件","uri":"/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E4%BD%BF%E7%94%A8truffle%E5%A5%97%E4%BB%B6/"},{"categories":["golang"],"content":"我们将用些简单的例子来尝试golang中sync包的各种有趣的情况 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:0:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"一个简单的DEMO package main import \"fmt\" var ( sharedCounter = 0 ) func add(count int) { for i := 0; i \u003c count; i++ { sharedCounter++ } } func sub(count int) { for i := 0; i \u003c count; i++ { sharedCounter-- } } func show() { fmt.Println(sharedCounter) } func main() { add(1000000) sub(1000000) show() } 程序很简单, 我们用一个共享变量sharedCounter作为一个计数器. add函数在计数器上循环添加一定的数值, sub则相反, show则是打印计数器当前的值. 程序运行结束后, sharedCounter应该为0, 上面代码的输出的确如此. ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:1:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"使用一个协程 如果对计数器进行加减的调用在不同的协程里面, 会怎么样呢? func main() { add(1000000) go sub(1000000) show() } 会得到1000000 , 因为go sub(1000000)刚启动, 程序就退出了. 或许我们应该等到sub函数执行结束 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:2:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"等待协程结束 错误的方式 如果有C语言开发背景, 可能会想到通过设置一个flag来指示运算是否结束, 比如: func sub(count int, done *bool) { for i := 0; i \u003c count; i++ { sharedCounter-- } *done = true } //.... func main() { add(1000000) done := false go sub(1000000, \u0026done) for !done { time.Sleep(time.Millisecond * 10) } show() } 这虽然也能得到正确的输出, 但非常不优雅. 正确的方式1 可以使用一个无缓冲的信道(或者说容量为1的信道)来充当flag //... func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { sharedCounter-- } done \u003c- true } //.... func main() { add(1000000) done := make(chan bool) go sub(1000000, done) \u003c-subDone show() } 这里利用了信道的特点: 当从信道中读取数据时,如果信道为空,读取将被阻塞直到有数据到达. 所以 \u003c-subDone 会一直阻塞, 直到通过subDone \u003c- true向其中写入了数据 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:2:1","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"使用2个协程 上面的例子中, sub(1000000, done)是在新的协程中运行的, add(1000000)却不是, 如果他们都在新协程中运行, 主程序应该如何等待他们结束呢 很容易想到, 使用两次\u003c-done 也就是说向信道索要两个计算完成的标志, add和 sub 计算完成后分别向其中放入标志. package main import \"fmt\" var ( sharedCounter = 0 ) func add(count int, done chan bool) { for i := 0; i \u003c count; i++ { sharedCounter++ } fmt.Println(\"add done\") done \u003c- true } func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { sharedCounter-- } fmt.Println(\"sub done\") done \u003c- true } func show() { fmt.Println(sharedCounter) } func main() { done := make(chan bool) go add(1000000, done) go sub(1000000, done) \u003c-done \u003c-done show() } 为了明确知道main函数的确是等待两个协程执行完毕了的, 我们在其中加入了fmt.Println(\"sub done\")这样的输出 运行程序, 得到 add done sub done 824933 Opps, 虽然add和sub 都执行完毕了,但是结果不对(并且多次运行的结果还不相同), 期望接收应该是0 再运行一次, 得到: sub done add done -481342 原因是add和sub在交叉读取和写入sharedCounter这个变量, 他们共享了变量, 但在读取和写入的时候出现**“竞态”** ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"竞态 有多个协程运行时, 对于每个协程而言,其内部代码时顺序执行的, 但无法确定协程之间的执行顺序, 那么就说这些协程是并发的 如果一段代码无论是顺序执行还是并发执行,其结果都是确定的,那么这个代码就是并发安全的. 相反, 并发不安全的代码,可能会出现死锁,活锁,竞态 竞态则表示代码可执行,但可能出现结果不一致(错误结果) ###解决方法1, 利用信道 func main() { done := make(chan bool) go add(1000000, done) \u003c-done //1 go sub(1000000, done) \u003c-done //2 show() } 在add执行完毕之前, 首先会堵塞在//1处, func add(count int, done chan bool) { //.... done \u003c- true } add函数执行最后一句 done \u003c- true 后 \u003c-done //1能取到值, 接触阻塞. 然后继续往下执行sub函数. 这虽然能得到正确输出, 但, 我们发现, 这实际是将并行执行修改成了串行执行. ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:1","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"解决方法2, 利用 Mutex 或 RWMutex sync.Mutex 可能是同步包中使用最广泛的原语。它允许对共享资源进行互斥（不能同时访问). mutex := \u0026sync.Mutex{} mutex.Lock() //.... 更新共享变量 mutex.Unlock() 注意: 在官方文档中有这么一句 “Values containing the types defined in this package should not be copied.” (“包含这个包中定义的类型的值不应该被复制。”) . 我们直到值传递就是复制然后传递, 所以我们代码中的mutex用的是引用传递. package main import ( \"fmt\" \"sync\" ) var ( sharedCounter = 0 mutex = \u0026sync.Mutex{} ) func add(count int, done chan bool) { for i := 0; i \u003c count; i++ { mutex.Lock() sharedCounter++ mutex.Unlock() } fmt.Println(\"add done\") done \u003c- true } func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { mutex.Lock() sharedCounter-- mutex.Unlock() } fmt.Println(\"sub done\") done \u003c- true } func show() { fmt.Println(sharedCounter) } func main() { done := make(chan bool) go add(1000000, done) go sub(1000000, done) \u003c-done \u003c-done show() } 在读写sharedCounter之前先Lock(), 用完后Unlock() 如果我们在进行计算的时候加上点打印(仅测试用,非常影响速度) for i := 0; i \u003c count; i++ { mutex.Lock() fmt.Println(\"--\") // fmt.Println(\"++\") sharedCounter-- // sharedCounter++ mutex.Unlock() } 则可以看到 ++ 和 – 是交叉着打印的, 说明是并行执行的. 另外, 还有RWMutex (读写锁), 除了与Mutex相同的Lock()和Unlock()方法外, 其还有用于共享读操作的RLock()和RUnlock(), 在读取共享变量时允许同时多个读取器能提高效率. 所以在频繁读写操作的代码中, 使用RWMutex效率要比Mutex高 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:2","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"解决方法3, 利用原子操作 原子操作在\"sync/atomic\"包中. 利用这个包中提供的函数可实现\"无锁版\"的共享变量读写 原子操作即是进行过程中不能被中断的操作，针对某个值的原子操作在被进行的过程中，CPU绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的CPU指令代表和完成。原子操作是无锁的，常常直接通过CPU指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作 package main import ( \"fmt\" \"sync/atomic\" ) var ( sharedCounter = int64(0) ) func add(count int, done chan bool) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, 1) // } fmt.Println(\"add done\") done \u003c- true } func sub(count int, done chan bool) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, -1) // } fmt.Println(\"sub done\") done \u003c- true } func show() { fmt.Println(sharedCounter) } func main() { done := make(chan bool) go add(1000000, done) go sub(1000000, done) \u003c-done \u003c-done show() } 原子操作的常用接口如下(以int32为例) //将addr指向的值和old进行比较, 如果相等,则将new赋值到addr指向的位置,并返回true, 如果不相等,则直接返回false func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) //使用原子操作,将addr指向的位置增加一个delta func AddInt32(addr *int32, delta int32) (new int32) //原子读取 //当我们要读取一个变量的时候，很有可能这个变量正在被写入，这个时候，我们就很有可能读取到写到一半的数据。 所以读取操作是需要一个原子行为的。 func LoadInt32(addr *int32) (val int32) //读取是有原子性的操作的，同样写入atomic包也提供了相关的操作包 func StoreInt32(addr *int32, val int32) //此类型的值相当于一个容器，可以被用来“原子地\"存储（Store）和加载（Load）任意类型的值。当然这个类型也是原子性的。 //有了atomic.Value这个类型，这样用户就可以在不依赖Go内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。 // A Value must not be copied after first use. type Value struct { v interface{} } 原子操作与互斥锁的区别 首先atomic操作的优势是更轻量，比如CAS可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作。这可以大大的减少同步对程序性能的损耗。 原子操作也有劣势。还是以CAS操作为例，使用CAS操作的做法趋于乐观，总是假设被操作值未曾被改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换，那么在被操作值被频繁变更的情况下，CAS操作并不那么容易成功。而使用互斥锁的做法则趋于悲观，我们总假设会有并发的操作要修改被操作的值，并使用锁将相关操作放入临界区中加以保护。 下面是几点区别： 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作 原子操作是无锁的，常常直接通过CPU指令直接实现 原子操作中的cas趋于乐观锁，CAS操作并不那么容易成功，需要判断，然后尝试处理 可以把互斥锁理解为悲观锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程 不要轻易使用atomic https://texlution.com/post/golang-lock-free-values-with-atomic-value/ ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:3:3","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"其它并发控制方法 上面的例子中, 我们都是使用的信道来进行并发控制 (done \u003c- true与\u003c-done), 这只是常用的方法之一 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:4:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"WaitGroup sync.WaitGroup 拥有一个内部计数器。如果此计数器等于 0，则 Wait() 方法立即返回。否则，它将被阻塞，直到计数器为 0。 要增加计数器，我们必须使用 Add(int)。要减少它，我们可以使用 Done() （将减少 1）或具有负值的相同 Add(int) 方法。 package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) var ( sharedCounter = int64(0) ) func add(count int, wg *sync.WaitGroup) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, 1) } fmt.Println(\"add done\") wg.Done() } func sub(count int, wg *sync.WaitGroup) { for i := 0; i \u003c count; i++ { atomic.AddInt64(\u0026sharedCounter, -1) } fmt.Println(\"sub done\") wg.Done() } func show() { fmt.Println(sharedCounter) } func main() { wg := sync.WaitGroup{} wg.Add(2) go add(1000000, \u0026wg) go sub(1000000, \u0026wg) wg.Wait() show() } 注意:传递 WaitGroup时要使用引用传递(指针), 其不应该被复制. func sub(count int, wg *sync.WaitGroup) ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:4:1","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"context.Context Context提供了2个功能 控制子协程结束 传递值 其不在sync包中, 后面专门讲 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:4:2","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Pool 对象复用 其提供一个\"并发安全\"的可复用的对象池. 用来减少频繁GC所代理的压力. 其大概意思是: 如果有旧对象可用,则用旧的, 没有再New一个 参考这批文章: https://www.cnblogs.com/qcrao-2018/p/12736031.html 以及这里 https://geektutu.com/post/hpg-sync-pool.html 在实际开发工作中, 不要一上来就想做使用sync.Pool它通常会带来问题(因为其Get出来的对象的状态是不确定的), 而应该遵循下面的原则: 根据你收集到的需求设计你的代码（不要跳过这个步骤）。 编写最简单、最清晰、最愚蠢的设计实现。 如果客户满意，就停止 如果客户不满意，而且他们认为应用程序的性能不能满足他们的要求，那么就剖析。 解决最高性能的主导者 剖析并进入第五阶段。然后进入3 如果实在搞不定, 再想想sync.Pool ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:5:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Once 只执行一次 sync.Once 提供了一种方法, 让相关代码只被执行一次 实际开发过程中, 经常有这样的场景: 你做了一个叫做lowLevelApi的包, 用于控制底层设备, 比如开关LED, 但在调用开关LED之前需要确保一些初始化工作已经完成, 所以你写了一个InitEnv的函数, 并告诉其它开发人员: 一定要先初始化哦. package lowLevelApi import \"fmt\" func InitEnv() { fmt.Println(\"init environment\") } func LedOn() { fmt.Println(\"LedOn\") } func LedOff() { fmt.Println(\"LedOff\") } 其它开发人员经常会问你: 这个初始化函数如果被重复调用不会出问题吧? 因为他们的代码通常会这样写: package main import ( \"fmt\" \"goplayground/lowLevelApi\" ) func turnLedOn() { fmt.Println(\"Turning LED on\") lowLevelApi.InitEnv() lowLevelApi.LedOn() fmt.Println(\"LED on\") } func turnLedOff() { fmt.Println(\"Turning LED off\") lowLevelApi.InitEnv() lowLevelApi.LedOff() fmt.Println(\"LED off\") } func main() { turnLedOn() turnLedOff() } 上面的代码会输出 Turning LED on InitEnv LedOn LED on Turning LED off InitEnv LedOff LED off 为了防止重复调用InitEnv()可能带来的问题, 则可以使用sync.Once var ( once sync.Once ) func InitEnv() { once.Do(func() { fmt.Println(\"InitEnv\") }) } 这样InitEnv()即使被多次调用, 其内部逻辑只会执行一次 Turning LED on InitEnv LedOn LED on Turning LED off LedOff LED off sync.Once 常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。 init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。 sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:6:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Cond 条件变量 sync.Cond 用于协调多个协程访问共享资源, 其中某些协程处于阻塞状态, 另外一个协程在条件准备好的时候来讲其它协程唤醒. 下面的例子中 InitEnv函数需要一点时间在准备sharedCounter 的初始值, 在这期间Add和sub处于Wait状态, 当准备好后, 将通知 Add和Sub继续向下执行 package main import ( \"fmt\" \"sync\" \"time\" ) var ( sharedCounter int ) func InitEnv(c *sync.Cond) { fmt.Println(\"begin InitEnv\") time.Sleep(time.Second * 1) c.L.Lock() sharedCounter = 10 c.L.Unlock() fmt.Println(\"Init Env Done, broadcast...\") c.Broadcast() } func Add(cout int, c *sync.Cond) { c.L.Lock() c.Wait() sharedCounter += cout c.L.Unlock() fmt.Println(\"Add Done\") } func Sub(count int, c *sync.Cond) { c.L.Lock() c.Wait() sharedCounter -= count c.L.Unlock() fmt.Println(\"Sub Done\") } func main() { cond := sync.NewCond(\u0026sync.Mutex{}) go InitEnv(cond) go Add(5, cond) go Sub(2, cond) time.Sleep(2 * time.Second) fmt.Println(\"Final Counter:\", sharedCounter) } 输出 begin InitEnv Init Env Done, broadcast... Add Done Sub Done Final Counter: 13 c.Broadcast()唤醒所有等待的协程, 另外还有一个Signal()方法, 用于唤醒一个协程. sync.Cond一般用于一对多的情况, 如果是一对一的情况, 用一个信道就可以轻松解决了 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:7:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"sync.Map 内置的map不是并发安全的, 所以 sync.Map 提供了一个功能与map类似但是并发安全的版本 可以参考这篇文章 https://juejin.cn/post/6844903895227957262 ","date":"2022-06-12","objectID":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/:8:0","tags":["go","sync"],"title":"聊聊go语言中的sync","uri":"/%E8%81%8A%E8%81%8Ago%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84sync/"},{"categories":["golang"],"content":"go语言中net/http包对http服务与请求的处理 ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"简单的文件服务器 package main import ( \"log\" \"net/http\" ) func main() { err := http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\".\"))) if err != nil { log.Fatal(err) } } 上面这个例子创建了一个以当前目录为站点跟目录的文件服务器, 我一般用这个来作为局域网文件共享. 然后写一个函数放到bash.rc 或zshrc中 #文件服务器 function fileserver(){ echo \"start file server :12345\" cat \u003c\u003cEOF | tee /tmp/fileserver.go | go run /tmp/fileserver.go package main import ( \"log\" \"net/http\" ) func main() { err := http.ListenAndServe(\":12345\", http.FileServer(http.Dir(\".\"))) if err != nil { log.Fatal(err) } } EOF } OSX MP16 ~/Downloads ❯ fileserver start file server :12345 Python中有相同的功能 python3 -m SimpleHTTPServer 7777 或 python3 -m http.server ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"一个简单的WebServer package main import ( \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { _, err := w.Write([]byte(\"Hello World!\\n\")) if err != nil { log.Println(err) } }) err := http.ListenAndServe(\":12345\", nil) if err != nil { log.Fatal(err) } } 访问一下试试: OSX MP16 ~/Downloads/goplayground ❯ curl http://localhost:12345 Hello World! ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"http.HandleFunc http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { //... }) 该方法提供了一种指定如何处理特定路由的请求的方法, 第一个参数为路由, 第二个参数为处理函数. 处理函数可写成匿名函数, 也可以声明为一个独立的函数 func rootHandler(w http.ResponseWriter, r *http.Request) { _, err := w.Write([]byte(\"\u003ch1 style=\\\"color:Tomato;\\\"\u003eHello World\u003c/h1\u003e\")) if err != nil { log.Println(err) } } func main() { http.HandleFunc(\"/\", rootHandler) //... } 函数的第一个参数是http.ResponseWriter类型的值。这是用于向任何连接的HTTP客户端发送响应的机制。这也是响应标头的设置方式,比如w.WriteHeader(http.StatusOK)。第二个论点是指向http.Request的指针。这是从网络请求中检索数据的方式。例如，可以通过请求指针访问表单提交的详细信息 比如 下面的方法, 使用 http://127.0.0.1:12345/?key=date 时将返回当前的日期, 确实key=或key不正确时返回http.StatusBadRequest func rootHandler(w http.ResponseWriter, r *http.Request) { keys, ok := r.URL.Query()[\"key\"] if !ok || len(keys[0]) \u003c 1 { log.Println(\"Url Param 'key' is missing\") w.WriteHeader(http.StatusBadRequest) _, err := w.Write([]byte(\"Url Param 'key' is missing\")) if err != nil { log.Println(err) return } return } key := keys[0] switch key { case \"date\": w.WriteHeader(http.StatusOK) _, err := w.Write([]byte(time.Now().Format(\"2006-01-02\"))) if err != nil { log.Println(err) } default: w.WriteHeader(http.StatusBadRequest) _, _ = w.Write([]byte(\"Invalid key\")) log.Println(\"Invalid key\") } } ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"http.ResponseWriter 用于向任何连接的HTTP客户端发送响应 设置相应标志头: w.WriteHeader(http.StatusOK) 获取或实则响应头 w.Header().Set(\"content-type\", \"application/json\") w.Header().Add(\"foo\", \"bar\") 写入相应数据: w.Write([]byte(time.Now().Format(\"2006-01-02\"))) 例子: package main import ( \"encoding/json\" \"log\" \"net/http\" ) type SystemInfo struct { Hostname string `json:\"hostname\"` Uptime string `json:\"uptime\"` } func rootHandler(w http.ResponseWriter, r *http.Request) { info := SystemInfo{ Hostname: \"test\", Uptime: \"2022-01-01 00:00:00\", } w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) bytes, _ := json.Marshal(info) _, err := w.Write(bytes) if err != nil { log.Println(\"Error writing response: \", err) } } func main() { http.HandleFunc(\"/\", rootHandler) err := http.ListenAndServe(\":12345\", nil) if err != nil { log.Fatal(err) } } OSX MP16 ~ ❯ curl localhost:12345 {\"hostname\":\"test\",\"uptime\":\"2022-01-01 00:00:00\"} ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:1","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"*http.Request 指向http.Request的指针, 通过改指针可以获取请求中的各种数据, 比如 获取基本信息 func rootHandler(w http.ResponseWriter, r *http.Request) { fmt.Println(\"User Agent: \", r.UserAgent()) fmt.Println(\"Host: \", r.Host) fmt.Println(\"Remote Address: \", r.RemoteAddr) fmt.Println(\"Request URI: \", r.RequestURI) fmt.Println(\"Method: \", r.Method) fmt.Println(\"URL: \", r.URL) fmt.Println(\"Header: \", r.Header) w.WriteHeader(http.StatusOK) } 输出: User Agent: curl/7.79.1 Host: localhost:12345 Remote Address: 127.0.0.1:58967 Request URI: / Method: GET URL: / Header: map[Accept:[*/*] User-Agent:[curl/7.79.1]] 获取cookie func rootHandler(w http.ResponseWriter, r *http.Request) { //获取所有 for _, c := range r.Cookies() { fmt.Printf(\"%s : %q\\n\", c.Name, c.Value) } //获取指定 c, err := r.Cookie(\"token\") if err != nil { log.Println(err) } fmt.Printf(\"%s : %q\\n\", c.Name, c.Value) w.WriteHeader(http.StatusOK) } curl --cookie \"token=abcdefg\" http://localhost:12345 获取GET参数 获取所有参数 args := r.URL.Query() 获取指定参数(注:参数可能被重复写多次) 比如: localhost:12345/?id=5 func rootHandler(w http.ResponseWriter, r *http.Request) { ids, ok := r.URL.Query()[\"id\"] if !ok || len(ids[0]) \u003c 1 { log.Println(\"Url Param 'id' is missing\") return } id := ids[0] log.Println(\"Url Param 'id' is: \" + id) w.WriteHeader(http.StatusOK) } 或者 func rootHandler(w http.ResponseWriter, r *http.Request) { id := r.FormValue(\"id\") if id == \"\" { log.Println(\"Url Param 'id' is missing\") } fmt.Println(\"id:\", id) w.WriteHeader(http.StatusOK) } 也可以通过r.Form来获取Get参数 获取PATCH, POST or PUT参数 比如 curl -d \"id=5\u0026format=1\" http://localhost:12345/ func rootHandler(w http.ResponseWriter, r *http.Request) { //parse err := r.ParseForm() if err != nil { log.Println(\"ParseForm error:\", err) } //get post args for k, v := range r.PostForm { log.Println(\"key:\", k) log.Println(\"val:\", v) // v []string } w.WriteHeader(http.StatusOK) } 输出 2022/06/06 15:14:46 key: id 2022/06/06 15:14:46 val: [5] 2022/06/06 15:14:46 key: format 2022/06/06 15:14:46 val: [1] ParseForm会填充r.Form和r.PostForm。 对于所有的请求，ParseForm解析来自URL的原始查询并更新r.Form。 对于POST、PUT和PATCH请求，它也读取请求正文，将其解析为一个表单，并将结果放入r.PostForm和r.Form中。在r.Form中，请求正文参数优先于URL查询字符串值。 如果请求体的大小还没有被MaxBytesReader限制，那么其大小将被限制在10MB。 对于其他HTTP方法，或者当内容类型不是application/x-www-form-urlencoded时，请求正文不被读取，并且r.PostForm被初始化为一个非零的空值。 ParseMultipartForm自动调用ParseForm。ParseForm是幂等的。 r.Form属性包含了post表单和url中的get参数。 r.PostForm属性只包含了post表单参数。 获取指定参数, 比如 func rootHandler(w http.ResponseWriter, r *http.Request) { err := r.ParseForm() if err != nil { log.Println(\"ParseForm error:\", err) } ids := r.PostForm.Get(\"id\") //获取id参数的第一个值 log.Println(\"id:\", ids) w.WriteHeader(http.StatusOK) } 或者 func rootHandler(w http.ResponseWriter, r *http.Request) { id := r.PostFormValue(\"id\") if id == \"\" { log.Println(\"Url Param 'id' is missing\") } fmt.Println(\"id:\", id) w.WriteHeader(http.StatusOK) } 获取上传文件 比如 curl -F \"file=@IMG_1526.PNG;type=image/png\" http://localhost:12345/upload 下面代码中: r.ParseMultipartForm(10 \u003c\u003c 20)将一个请求体解析为multipart/form-data。整个请求正文被解析，并且其文件部分最多存储在maxMemory字节的内存中，其余部分则存储在磁盘的临时文件中。ParseMultipartForm在必要时调用ParseForm。如果ParseForm返回一个错误，ParseMultipartForm将其返回，但也继续解析请求正文。在对ParseMultipartForm进行一次调用后，随后的调用没有任何影响. FormFile 返回提供的表单key的第一个文件。如果需要，FormFile会调用ParseMultipartForm和ParseForm。 package main import ( \"io\" \"log\" \"mime/multipart\" \"net/http\" \"os\" ) func uploadHandler(w http.ResponseWriter, r *http.Request) { // Parse the multipart form in the request err := r.ParseMultipartForm(10 \u003c\u003c 20) // 10 MiB if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } // FormFile returns the first file for the given key `file` // it also returns the FileHeader, so we can get the Filename, the Header and the size of the file file, handler, err := r.FormFile(\"file\") if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } defer func(file multipart.File) { err := file.Close() if err != nil { log.Println(err) } }(file) err = os.MkdirAll(\"./upload\", 0777) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) re","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:2","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"Handler , Handle , HandleFunc 与 http.ListenAndServe 使用默认的Handler 先看一个简单的例子 package main import \"net/http\" func main() { http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello, world!\")) }) http.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is my Blog\")) }) http.ListenAndServe(\":12345\", nil) } 在启动一个HttpServer的时候, 其实我们就关心2个东西: 地址 路由: 将请求对应到相应的处理函数中去 这两个参数 在http.ListenAndServe(\":12345\", nil)中进行设置的, 第一个为地址, 第二个传递处理函数. 如果传递nil, 则采用默认的 The handler is typically nil, in which case the DefaultServeMux is used. http.ListenAndServe的实现如下: func ListenAndServe(addr string, handler Handler) error { server := \u0026Server{Addr: addr, Handler: handler} return server.ListenAndServe() } type Handler interface { ServeHTTP(ResponseWriter, *Request) } 可以看到 Handler是一个接口, 实现这个接口的话, 我们可以创建自己的Handler 自定义Handler 定义一个结构体, 结构体实现 ServeHTTP(w http.ResponseWriter, r *http.Request)方法 然后使用 Handle函数进行路由注册 package main import \"net/http\" type MyIndexHandler struct { } func (h *MyIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello World\")) } type MyBlogHandler struct { } func (h *MyBlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is my Blog\")) } func main() { mux := http.NewServeMux() mux.Handle(\"/\", \u0026MyIndexHandler{}) mux.Handle(\"/blog\", \u0026MyBlogHandler{}) http.ListenAndServe(\":12345\", mux) } OSX MP16 ~ ❯ curl localhost:12345 Hello World OSX MP16 ~ ❯ curl localhost:12345/blog This is my Blog OSX MP16 ~ ❯ 但这明显看出来, 对每一个路由 都要高写一个xxxHandler结构体和实现ServeHTTP, 看上去非常混乱 这时候就可以用mux.HandleFunc来实现路由 package main import \"net/http\" func main() { mux := http.NewServeMux() mux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Hello World\")) }) mux.HandleFunc(\"/blog\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"This is my Blog\")) }) http.ListenAndServe(\":12345\", mux) } 自定义ServeMux 在上面的例子中, mux := http.NewServeMux()还是使用了默认router, 其简单的同时也有不少缺点 比如, 其是通过url进行路由, 但不支持基于方法(GET, POST…)的路由, 不支持正则表达式等等 参考这个 https://www.alexedwards.net/blog/which-go-router-should-i-use ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:3","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["golang"],"content":"人气Web框架 参考这篇文章, https://blog.51cto.com/coderaction/3001008 其中有各框架的对比, 功能上iris最全 https://github.com/kataras/iris ","date":"2022-06-06","objectID":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":["go","http"],"title":"Go语言中的http服务器","uri":"/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]