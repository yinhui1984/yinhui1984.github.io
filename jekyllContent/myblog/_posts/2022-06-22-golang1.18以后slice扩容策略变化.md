---
title: golang1.18以后slice扩容策略变化
author: yinhui
date: 2022-06-22
categories: [BlockChain, golang]
tags: [slice]     # TAG names should always be lowercase
math: false
mermaid: false
toc: true
---



golang1.18版本以前, 扩容策略:

> 当原 slice 容量小于 `1024` 的时候，新 slice 容量变成原来的 `2` 倍；原 slice 容量超过 `1024`，新 slice 容量变成原来的`1.25`倍。



在1.18版本更新之后，slice的扩容策略变为了:

> 当原slice容量小于`256`的时候，新slice容量为原来的`2`倍；原slice容量超过`256`，新slice容量`newcap = oldcap+(oldcap+3*256)/4`





```go

// go@1.17   slice.go

func growslice(et *_type, old slice, cap int) slice {
  
  //....
  newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.cap < 1024 {
			newcap = doublecap
		} else {
			// Check 0 < newcap to detect overflow
			// and prevent an infinite loop.
			for 0 < newcap && newcap < cap {
				newcap += newcap / 4
			}
			// Set newcap to the requested cap when
			// the newcap calculation overflowed.
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
  
  //....
  
}
```



```go
// go 1.18 slice.go

func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		const threshold = 256
		if old.cap < threshold {
			newcap = doublecap
		} else {
			for 0 < newcap && newcap < cap {
                // Transition from growing 2x for small slices
				// to growing 1.25x for large slices. This formula
				// gives a smooth-ish transition between the two.
				newcap += (newcap + 3*threshold) / 4
			}
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
	// ……
    
}
```



可以通过下面的demo程序来看扩容变化

```go
package main

import "fmt"

func main() {
	s := make([]int, 0)

	oldCap := cap(s)

	for i := 0; i < 2048; i++ {
		s = append(s, i)
		currentCap := cap(s)
		if oldCap != currentCap {
			fmt.Printf("current cap: %d\n", currentCap)
			oldCap = currentCap
		}
	}
}
```



